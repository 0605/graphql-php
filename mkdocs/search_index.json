{
    "docs": [
        {
            "location": "/", 
            "text": "About GraphQL\n\n\nGraphQL is a modern way to build HTTP APIs consumed by web and mobile clients.\nIt is intended to be a replacement for REST and SOAP APIs (even for \nexisting applications\n).\n\n\nGraphQL itself is a \nspecification\n designed by Facebook\nengineers. Various implementations of this specification were written \n\nfor different languages and environments\n.\n\n\nGreat overview of GraphQL features and benefits is presented on \nofficial website\n. \nAll of them equally apply to this PHP implementation. \n\n\nAbout graphql-php\n\n\ngraphql-php\n is a feature-complete implementation of GraphQL specification in PHP (5.4+, 7.0+). \nIt was originally inspired by \nreference JavaScript implementation\n \npublished by Facebook.\n\n\nThis library is a thin wrapper around your existing data layer and business logic. \nIt doesn't dictate how these layers are implemented or which storage engines \nare used. Instead it provides tools for creating rich API for your existing app. \n\n\nThese tools include:\n\n\n\n\nPrimitives to express your app as a Type System\n\n\nTools for validation and introspection of this Type System (for compatibility with tools like \nGraphiQL\n)\n\n\nTools for parsing, validating and executing GraphQL queries against this Type System\n\n\nRich error reporting, including query validation and execution errors\n\n\nOptional tools for parsing GraphQL Schema Definition language\n\n\n\n\nAlso several \ncomplementary tools\n are available which provide integrations with \nexisting PHP frameworks, add support for Relay, etc.\n\n\nCurrent Status\n\n\nFirst version of this library (v0.1) was released on August 10th 2015.\n\n\nCurrent version (v0.8) supports all features described by GraphQL specification \n(including April 2016 add-ons) as well as some experimental features like \nSchema Language parser.\n\n\nReady for real-world usage.\n\n\nGithub\n\n\nProject source code is \nhosted on GitHub\n.", 
            "title": "About"
        }, 
        {
            "location": "/#about-graphql", 
            "text": "GraphQL is a modern way to build HTTP APIs consumed by web and mobile clients.\nIt is intended to be a replacement for REST and SOAP APIs (even for  existing applications ).  GraphQL itself is a  specification  designed by Facebook\nengineers. Various implementations of this specification were written  for different languages and environments .  Great overview of GraphQL features and benefits is presented on  official website . \nAll of them equally apply to this PHP implementation.", 
            "title": "About GraphQL"
        }, 
        {
            "location": "/#about-graphql-php", 
            "text": "graphql-php  is a feature-complete implementation of GraphQL specification in PHP (5.4+, 7.0+). \nIt was originally inspired by  reference JavaScript implementation  \npublished by Facebook.  This library is a thin wrapper around your existing data layer and business logic. \nIt doesn't dictate how these layers are implemented or which storage engines \nare used. Instead it provides tools for creating rich API for your existing app.   These tools include:   Primitives to express your app as a Type System  Tools for validation and introspection of this Type System (for compatibility with tools like  GraphiQL )  Tools for parsing, validating and executing GraphQL queries against this Type System  Rich error reporting, including query validation and execution errors  Optional tools for parsing GraphQL Schema Definition language   Also several  complementary tools  are available which provide integrations with \nexisting PHP frameworks, add support for Relay, etc.", 
            "title": "About graphql-php"
        }, 
        {
            "location": "/#current-status", 
            "text": "First version of this library (v0.1) was released on August 10th 2015.  Current version (v0.8) supports all features described by GraphQL specification \n(including April 2016 add-ons) as well as some experimental features like \nSchema Language parser.  Ready for real-world usage.", 
            "title": "Current Status"
        }, 
        {
            "location": "/#github", 
            "text": "Project source code is  hosted on GitHub .", 
            "title": "Github"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Prerequisites\n\n\nThis documentation assumes your familiarity with GraphQL concepts. If it is not the case - \nfirst learn about  GraphQL on \nofficial website\n.\n\n\nInstallation\n\n\nUsing \ncomposer\n:\nadd \ncomposer.json\n file to your project root folder with following contents:\n\n\n{\n    \nrequire\n: {\n        \nwebonyx/graphql-php\n: \n^0.8\n\n    }\n}\n\n\n\n\nand run \ncomposer install\n. \n\n\nIf you already have composer.json file - simply run: \ncomposer require webonyx/graphql-php=\"^0.8\"\n\n\nUpgrading\n\n\nWe try to keep library releases backwards compatible. But when breaking changes are inevitable \nthey are explained in \nupgrade instructions\n.\n\n\nInstall Tools (optional)\n\n\nWhile it is possible to communicate with GraphQL API using regular HTTP tools it is way \nmore convenient for humans to use \nGraphiQL\n - an in-browser \nide for exploring GraphQL APIs.\n\n\nIt provides syntax-highlighting, auto-completion and auto-generated documentation for \nGraphQL API.\n\n\nThe easiest way to use it is to install one of the existing Google Chrome extensions:\n\n\n\n\nChromeiQL\n\n\nGraphiQL Feen\n\n\n\n\nAlternatively you can follow instructions on \nGraphiQL\n\npage and install it locally.\n\n\nHello World\n\n\nLet's create type system that will be capable to process following simple query:\n\n\nquery {\n  echo(message: \nHello World\n)\n}\n\n\n\n\nTo do so we need an object type with field \necho\n:\n\n\n?php\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\n\n$queryType = new ObjectType([\n    'name' =\n 'Query',\n    'fields' =\n [\n        'echo' =\n [\n            'type' =\n Type::string(),\n            'args' =\n [\n                'message' =\n Type::nonNull(Type::string()),\n            ],\n            'resolve' =\n function ($root, $args) {\n                return $root['prefix'] . $args['message'];\n            }\n        ],\n    ],\n]);\n\n\n\n\n(Note: type definition can be expressed in \ndifferent styles\n, \nbut this example uses \ninline\n style for simplicity)\n\n\nThe interesting piece here is \nresolve\n option of field definition. It is responsible for retuning \nvalue of our field. Values of \nscalar\n fields will be directly included in response while values of \n\ncomplex\n fields (objects, interfaces, unions) will be passed down to nested field resolvers \n(not in this example though).\n\n\nNow when our type is ready, let's create GraphQL endpoint for it \ngraphql.php\n:\n\n\n?php\nuse GraphQL\\GraphQL;\nuse GraphQL\\Schema;\n\n$schema = new Schema([\n    'query' =\n $queryType\n]);\n\n$rawInput = file_get_contents('php://input');\n\ntry {\n    $rootValue = ['prefix' =\n 'You said: '];\n    $result = GraphQL::execute($schema, $rawInput, $rootValue);\n} catch (\\Exception $e) {\n    $result = [\n        'error' =\n [\n            'message' =\n $e-\ngetMessage()\n        ]\n    ];\n}\nheader('Content-Type: application/json; charset=UTF-8');\necho json_encode($result);\n\n\n\n\nOur example is ready. Try it by running:\n\n\nphp -S localhost:8000 graphql.php\ncurl http://localhost:8000 -d \nquery { echo(message: \\\nHello World\\\n) }\n\n\n\n\n\nCheck out the full \nsource code\n of this example.\n\n\nObviously hello world only scratches the surface of what is possible. \nSo check out next example, which is closer to real-world apps.\nOr keep reading about \nschema definition\n.\n\n\nBlog example\n\n\nIt is often easier to start with full-featured example and then get back to documentation\nfor your own work. \n\n\nCheck out \nBlog example of GraphQL API\n.\nIt is quite close to real-world GraphQL hierarchies. Follow instructions and try it yourself in ~10 minutes.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#prerequisites", 
            "text": "This documentation assumes your familiarity with GraphQL concepts. If it is not the case - \nfirst learn about  GraphQL on  official website .", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/getting-started/#installation", 
            "text": "Using  composer :\nadd  composer.json  file to your project root folder with following contents:  {\n     require : {\n         webonyx/graphql-php :  ^0.8 \n    }\n}  and run  composer install .   If you already have composer.json file - simply run:  composer require webonyx/graphql-php=\"^0.8\"", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/#upgrading", 
            "text": "We try to keep library releases backwards compatible. But when breaking changes are inevitable \nthey are explained in  upgrade instructions .", 
            "title": "Upgrading"
        }, 
        {
            "location": "/getting-started/#install-tools-optional", 
            "text": "While it is possible to communicate with GraphQL API using regular HTTP tools it is way \nmore convenient for humans to use  GraphiQL  - an in-browser \nide for exploring GraphQL APIs.  It provides syntax-highlighting, auto-completion and auto-generated documentation for \nGraphQL API.  The easiest way to use it is to install one of the existing Google Chrome extensions:   ChromeiQL  GraphiQL Feen   Alternatively you can follow instructions on  GraphiQL \npage and install it locally.", 
            "title": "Install Tools (optional)"
        }, 
        {
            "location": "/getting-started/#hello-world", 
            "text": "Let's create type system that will be capable to process following simple query:  query {\n  echo(message:  Hello World )\n}  To do so we need an object type with field  echo :  ?php\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\n\n$queryType = new ObjectType([\n    'name' =  'Query',\n    'fields' =  [\n        'echo' =  [\n            'type' =  Type::string(),\n            'args' =  [\n                'message' =  Type::nonNull(Type::string()),\n            ],\n            'resolve' =  function ($root, $args) {\n                return $root['prefix'] . $args['message'];\n            }\n        ],\n    ],\n]);  (Note: type definition can be expressed in  different styles , \nbut this example uses  inline  style for simplicity)  The interesting piece here is  resolve  option of field definition. It is responsible for retuning \nvalue of our field. Values of  scalar  fields will be directly included in response while values of  complex  fields (objects, interfaces, unions) will be passed down to nested field resolvers \n(not in this example though).  Now when our type is ready, let's create GraphQL endpoint for it  graphql.php :  ?php\nuse GraphQL\\GraphQL;\nuse GraphQL\\Schema;\n\n$schema = new Schema([\n    'query' =  $queryType\n]);\n\n$rawInput = file_get_contents('php://input');\n\ntry {\n    $rootValue = ['prefix' =  'You said: '];\n    $result = GraphQL::execute($schema, $rawInput, $rootValue);\n} catch (\\Exception $e) {\n    $result = [\n        'error' =  [\n            'message' =  $e- getMessage()\n        ]\n    ];\n}\nheader('Content-Type: application/json; charset=UTF-8');\necho json_encode($result);  Our example is ready. Try it by running:  php -S localhost:8000 graphql.php\ncurl http://localhost:8000 -d  query { echo(message: \\ Hello World\\ ) }   Check out the full  source code  of this example.  Obviously hello world only scratches the surface of what is possible. \nSo check out next example, which is closer to real-world apps.\nOr keep reading about  schema definition .", 
            "title": "Hello World"
        }, 
        {
            "location": "/getting-started/#blog-example", 
            "text": "It is often easier to start with full-featured example and then get back to documentation\nfor your own work.   Check out  Blog example of GraphQL API .\nIt is quite close to real-world GraphQL hierarchies. Follow instructions and try it yourself in ~10 minutes.", 
            "title": "Blog example"
        }, 
        {
            "location": "/type-system/", 
            "text": "Type System\n\n\nTo start using GraphQL you are expected to implement a type hierarchy and expose it as \nSchema\n. \n\n\nIn \ngraphql-php\n \ntype\n is an instance of internal class from \n\nGraphQL\\Type\\Definition\n namespace: \nScalarType\n, \nObjectType\n, \nInterfaceType\n, \n\nUnionType\n, \nInputObjectType\n (or one of it's subclasses).\n\n\nBut most of the types in your schema will be \nobject types\n.\n\n\nType Definition Styles\n\n\nSeveral styles of type definitions are supported depending on your preferences.\n\n\nInline definitions:\n\n\n?php\nnamespace MyApp;\n\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\n\n$myType = new ObjectType([\n    'name' =\n 'MyType',\n    'fields' =\n [\n        'id' =\n Type::id()\n    ]\n]);\n\n\n\n\nClass per type:\n\n\n?php\nnamespace MyApp;\n\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\n\nclass MyType extends ObjectType\n{\n    public function __construct()\n    {\n        $config = [\n            // Note: 'name' is not needed in this form:\n            // it will be inferred from class name by omitting namespace and dropping \nType\n suffix\n            'fields' =\n [\n                'id' =\n Type::id()\n            ]\n        ];\n        parent::__construct($config);\n    }\n}\n\n\n\n\nYou can also mix-and-match styles for convenience. For example:\n\n\n?php\nnamespace MyApp;\n\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\n\nclass BlogPostType extends ObjectType\n{\n    public function __construct()\n    {\n        $config = [\n            'fields' =\n [\n                'body' =\n new ObjectType([\n                    'name' =\n 'BlogPostBody',\n                    'fields' =\n [\n                        'html' =\n Type::string(),\n                        'text' =\n Type::string(),\n                    ]\n                ])\n            ]\n        ];\n        parent::__construct($config);\n    }\n}\n\n\n\n\nType Registry\n\n\nEvery type must be presented in Schema by single instance (\ngraphql-php\n \nthrows when it discovers several instances with the same \nname\n in schema).\n\n\nTherefore if you define your type as separate PHP class you must ensure that only one \ninstance of that class is added to schema.\n\n\nTypical way to do this is to create registry of your types:\n\n\n?php\nnamespace MyApp;\n\nclass TypeRegistry\n{\n    private $myAType;\n    private $myBType;\n\n    public function myAType()\n    {\n        return $this-\nmyAType ?: ($this-\nmyAType = new MyAType($this));\n    }\n\n    public function myBType()\n    {\n        return $this-\nmyBType ?: ($this-\nmyBType = new MyBType($this));\n    }\n}\n\n\n\n\nAnd use this registry in type definition:\n\n\n?php\nnamespace MyApp;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\nclass MyAType extends ObjectType\n{\n    public function __construct(TypeRegistry $types) \n    {\n        parent::__construct([\n            'fields' =\n [\n                'b' =\n $types-\nmyBType()                \n            ]\n        ]);\n    }\n}\n\n\n\n\nObviously you can automate this registry as you wish to reduce boilerplate or even \nintroduce Dependency Injection Container if your types have other dependencies.\n\n\nAlternatively all methods of registry could be static if you prefer - then there is no need\nto pass it in constructor - instead just use use \nTypeRegistry::myAType()\n in your type definitions.", 
            "title": "Introduction"
        }, 
        {
            "location": "/type-system/#type-system", 
            "text": "To start using GraphQL you are expected to implement a type hierarchy and expose it as  Schema .   In  graphql-php   type  is an instance of internal class from  GraphQL\\Type\\Definition  namespace:  ScalarType ,  ObjectType ,  InterfaceType ,  UnionType ,  InputObjectType  (or one of it's subclasses).  But most of the types in your schema will be  object types .", 
            "title": "Type System"
        }, 
        {
            "location": "/type-system/#type-definition-styles", 
            "text": "Several styles of type definitions are supported depending on your preferences.  Inline definitions:  ?php\nnamespace MyApp;\n\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\n\n$myType = new ObjectType([\n    'name' =  'MyType',\n    'fields' =  [\n        'id' =  Type::id()\n    ]\n]);  Class per type:  ?php\nnamespace MyApp;\n\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\n\nclass MyType extends ObjectType\n{\n    public function __construct()\n    {\n        $config = [\n            // Note: 'name' is not needed in this form:\n            // it will be inferred from class name by omitting namespace and dropping  Type  suffix\n            'fields' =  [\n                'id' =  Type::id()\n            ]\n        ];\n        parent::__construct($config);\n    }\n}  You can also mix-and-match styles for convenience. For example:  ?php\nnamespace MyApp;\n\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\n\nclass BlogPostType extends ObjectType\n{\n    public function __construct()\n    {\n        $config = [\n            'fields' =  [\n                'body' =  new ObjectType([\n                    'name' =  'BlogPostBody',\n                    'fields' =  [\n                        'html' =  Type::string(),\n                        'text' =  Type::string(),\n                    ]\n                ])\n            ]\n        ];\n        parent::__construct($config);\n    }\n}", 
            "title": "Type Definition Styles"
        }, 
        {
            "location": "/type-system/#type-registry", 
            "text": "Every type must be presented in Schema by single instance ( graphql-php  \nthrows when it discovers several instances with the same  name  in schema).  Therefore if you define your type as separate PHP class you must ensure that only one \ninstance of that class is added to schema.  Typical way to do this is to create registry of your types:  ?php\nnamespace MyApp;\n\nclass TypeRegistry\n{\n    private $myAType;\n    private $myBType;\n\n    public function myAType()\n    {\n        return $this- myAType ?: ($this- myAType = new MyAType($this));\n    }\n\n    public function myBType()\n    {\n        return $this- myBType ?: ($this- myBType = new MyBType($this));\n    }\n}  And use this registry in type definition:  ?php\nnamespace MyApp;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\nclass MyAType extends ObjectType\n{\n    public function __construct(TypeRegistry $types) \n    {\n        parent::__construct([\n            'fields' =  [\n                'b' =  $types- myBType()                \n            ]\n        ]);\n    }\n}  Obviously you can automate this registry as you wish to reduce boilerplate or even \nintroduce Dependency Injection Container if your types have other dependencies.  Alternatively all methods of registry could be static if you prefer - then there is no need\nto pass it in constructor - instead just use use  TypeRegistry::myAType()  in your type definitions.", 
            "title": "Type Registry"
        }, 
        {
            "location": "/type-system/object-types/", 
            "text": "Object Type Definition\n\n\nObject Type is the most frequently used primitive in typical GraphQL application.\n\n\nConceptually Object Type is a collection of Fields. Each field in turn\nhas it's own type which allows to build complex hierarchies.\n\n\nIn \ngraphql-php\n object type is an instance of \nGraphQL\\Type\\Definition\\ObjectType\n \n(or one of it subclasses) which accepts configuration array in constructor:\n\n\n?php\nnamespace MyApp;\n\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Examples\\Blog\\Data\\DataSource;\nuse GraphQL\\Examples\\Blog\\Data\\Story;\n\n$userType = new ObjectType([\n    'name' =\n 'User',\n    'description' =\n 'Our blog visitor',\n    'fields' =\n [\n        'firstName' =\n [\n            'type' =\n Type::string(),\n            'description' =\n 'User first name'\n        ],\n        'email' =\n Type::string()\n    ]\n]);\n\n$blogStory = new ObjectType([\n    'name' =\n 'Story',\n    'fields' =\n [\n        'body' =\n Type::string(),\n        'author' =\n [\n            'type' =\n $userType,\n            'description' =\n 'Story author',\n            'resolve' =\n function(Story $blogStory) {\n                return DataSource::findUser($blogStory-\nauthorId);\n            }\n        ],\n        'likes' =\n [\n            'type' =\n Type::listOf($userType),\n            'description' =\n 'List of users who liked the story',\n            'args' =\n [\n                'limit' =\n [\n                    'type' =\n Type::int(),\n                    'description' =\n 'Limit the number of recent likes returned',\n                    'defaultValue' =\n 10\n                ]\n            ],\n            'resolve' =\n function(Story $blogStory, $args) {\n                return DataSource::findLikes($blogStory-\nid, $args['limit']);\n            }\n        ]\n    ]\n]);\n\n\n\n\nThis example uses \ninline\n style for Object Type definitions, but you can also use\n\n\ninheritance\n.\n\n\nConfiguration options\n\n\nObject type constructor expects configuration array. Below is a full list of available options:\n\n\n\n\n\n\n\n\nOption\n\n\nType\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nname\n\n\nstring\n\n\nRequired.\n Unique name of this object type within Schema\n\n\n\n\n\n\nfields\n\n\narray\n or \ncallback\n returning \narray\n\n\nRequired\n. Array describing object fields. See \nFields\n section below for expected structure of each array entry. See also section on \nCircular types\n for explanation of when to use callback for this option.\n\n\n\n\n\n\ndescription\n\n\nstring\n\n\nPlain-text description of this type for clients (e.g. used by \nGraphiQL\n for auto-generated documentation)\n\n\n\n\n\n\ninterfaces\n\n\narray\n or \ncallback\n returning \narray\n\n\nList of interfaces implemented by this type. See \nInterface Types\n for details. See also section on \nCircular types\n for explanation of when to use callback for this option.\n\n\n\n\n\n\nisTypeOf\n\n\ncallback\n returning \nboolean\n\n\nfunction($value, $context, GraphQL\\Type\\Definition\\ResolveInfo $info)\n Expected to return \ntrue\n if \n$value\n qualifies for this type (see section about \nAbstract Type Resolution\n for explanation).\n\n\n\n\n\n\nresolveField\n\n\ncallback\n returning \nmixed\n\n\nfunction($value, $args, $context, GraphQL\\Type\\Definition\\ResolveInfo $info)\n Given the \n$value\n of this type it is expected to return value for field defined in \n$info-\nfieldName\n. Good place to define type-specific strategy for field resolution. See section on \nData Fetching\n for details.\n\n\n\n\n\n\n\n\nField configuration options\n\n\nBelow is a full list of available field configuration options:\n\n\n\n\n\n\n\n\nOption\n\n\nType\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nname\n\n\nstring\n\n\nRequired.\n Name of the field. When not set - inferred from \nfields\n array key (read about \nshorthand field definition\n below)\n\n\n\n\n\n\ntype\n\n\nType\n\n\nRequired.\n Instance of internal or custom type. Note: type must be represented by single instance within schema (see also \nType Registry\n)\n\n\n\n\n\n\nargs\n\n\narray\n\n\nArray of possible type arguments. Each entry is expected to be an array with keys: \nname\n, \ntype\n, \ndescription\n, \ndefaultValue\n. See \nField Arguments\n section below.\n\n\n\n\n\n\nresolve\n\n\ncallback\n\n\nfunction($value, $args, $context, GraphQL\\Type\\Definition\\ResolveInfo $info)\n Given the \n$value\n of this type it is expected to return value for current field. See section on \nData Fetching\n for details\n\n\n\n\n\n\ndescription\n\n\nstring\n\n\nPlain-text description of this field for clients (e.g. used by \nGraphiQL\n for auto-generated documentation)\n\n\n\n\n\n\ndeprecationReason\n\n\nstring\n\n\nText describing why this field is deprecated. When not empty - field will not be returned by introspection queries (unless forced)\n\n\n\n\n\n\n\n\nField arguments\n\n\nEvery field on a GraphQL object type can have zero or more arguments, defined in \nargs\n option of field definition.\nEach argument is an array with following options:\n\n\n\n\n\n\n\n\nOption\n\n\nType\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nname\n\n\nstring\n\n\nRequired.\n Name of the argument. When not set - inferred from \nargs\n array key\n\n\n\n\n\n\ntype\n\n\nType\n\n\nRequired.\n Instance of one of \nInput Types\n (\nscalar\n, \nenum\n, \nInputObjectType\n + any combination of those with \nnonNull\n and \nlistOf\n modifiers)\n\n\n\n\n\n\ndescription\n\n\nstring\n\n\nPlain-text description of this argument for clients (e.g. used by \nGraphiQL\n for auto-generated documentation)\n\n\n\n\n\n\ndefaultValue\n\n\nscalar\n\n\nDefault value for this argument\n\n\n\n\n\n\n\n\nShorthand field definitions\n\n\nFields can be also defined in \nshorthand\n notation (with only \nname\n and \ntype\n options):\n\n\n'fields' =\n [\n    'id' =\n Type::id(),\n    'fieldName' =\n $fieldType\n]\n\n\n\n\nwhich is equivalent of:\n\n\n'fields' =\n [\n    'id' =\n ['type' =\n Type::id()],\n    'fieldName' =\n ['type' =\n $fieldName]\n]\n\n\n\n\nwhich is in turn equivalent of full form:\n\n\n'fields' =\n [\n    ['name' =\n 'id', 'type' =\n Type::id()],\n    ['name' =\n 'fieldName', 'type' =\n $fieldName]\n]\n\n\n\n\nSame shorthand notation applies to field arguments as well.\n\n\nRecurring and circular types\n\n\nAlmost all real-world applications contain recurring or circular types. \nThink user friends or nested comments for example. \n\n\ngraphql-php\n allows such types, but you have to use \ncallback\n in \noption \nfields\n (and/or \ninterfaces\n).\n\n\nFor example:\n\n\n$userType = null;\n\n$userType = new ObjectType([\n    'name' =\n 'User',\n    'fields' =\n function() use (\n$userType) {\n        return [\n            'email' =\n [\n                'type' =\n Type::string()\n            ],\n            'friends' =\n [\n                'type' =\n Type::listOf($userType)\n            ]\n        ];\n    }\n]);\n\n\n\n\nSame example for \ninheritance style of type definitions\n using \nTypeRegistry\n:\n\n\n?php\nnamespace MyApp;\n\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\nclass UserType extends ObjectType\n{\n    public function __construct()\n    {\n        $config = [\n            'fields' =\n function() {\n                return [\n                    'email' =\n MyTypes::string(),\n                    'friends' =\n MyTypes::listOf(MyTypes::user())\n                ];\n            }\n        ];\n        parent::__construct($config);\n    }\n}\n\nclass MyTypes \n{\n    private static $user;\n\n    public static function user()\n    {\n        return self::$user ?: (self::$user = new UserType());\n    }\n\n    public static function string()\n    {\n        return Type::string();\n    }\n\n    public static function listOf($type)\n    {\n        return Type::listOf($type);\n    }\n}\n\n\n\n\nField Resolution\n\n\nField resolution is the primary mechanism in \ngraphql-php\n for returning actual data for your fields.\nIt is implemented using \nresolveField\n callback in type definition or \nresolve\n\ncallback in field definition (which has precedence).\n\n\nRead section on \nData Fetching\n for complete description of this process.\n\n\nCustom Metadata\n\n\nAll types in \ngraphql-php\n accept configuration array. In some cases you may be interested in \npassing your own metadata for type or field definition.\n\n\ngraphql-php\n preserves original configuration array in every type or field instance in \npublic property \n$config\n. Use it to implement app-level mappings and definitions.", 
            "title": "Object Types"
        }, 
        {
            "location": "/type-system/object-types/#object-type-definition", 
            "text": "Object Type is the most frequently used primitive in typical GraphQL application.  Conceptually Object Type is a collection of Fields. Each field in turn\nhas it's own type which allows to build complex hierarchies.  In  graphql-php  object type is an instance of  GraphQL\\Type\\Definition\\ObjectType  \n(or one of it subclasses) which accepts configuration array in constructor:  ?php\nnamespace MyApp;\n\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Examples\\Blog\\Data\\DataSource;\nuse GraphQL\\Examples\\Blog\\Data\\Story;\n\n$userType = new ObjectType([\n    'name' =  'User',\n    'description' =  'Our blog visitor',\n    'fields' =  [\n        'firstName' =  [\n            'type' =  Type::string(),\n            'description' =  'User first name'\n        ],\n        'email' =  Type::string()\n    ]\n]);\n\n$blogStory = new ObjectType([\n    'name' =  'Story',\n    'fields' =  [\n        'body' =  Type::string(),\n        'author' =  [\n            'type' =  $userType,\n            'description' =  'Story author',\n            'resolve' =  function(Story $blogStory) {\n                return DataSource::findUser($blogStory- authorId);\n            }\n        ],\n        'likes' =  [\n            'type' =  Type::listOf($userType),\n            'description' =  'List of users who liked the story',\n            'args' =  [\n                'limit' =  [\n                    'type' =  Type::int(),\n                    'description' =  'Limit the number of recent likes returned',\n                    'defaultValue' =  10\n                ]\n            ],\n            'resolve' =  function(Story $blogStory, $args) {\n                return DataSource::findLikes($blogStory- id, $args['limit']);\n            }\n        ]\n    ]\n]);  This example uses  inline  style for Object Type definitions, but you can also use  inheritance .", 
            "title": "Object Type Definition"
        }, 
        {
            "location": "/type-system/object-types/#configuration-options", 
            "text": "Object type constructor expects configuration array. Below is a full list of available options:     Option  Type  Notes      name  string  Required.  Unique name of this object type within Schema    fields  array  or  callback  returning  array  Required . Array describing object fields. See  Fields  section below for expected structure of each array entry. See also section on  Circular types  for explanation of when to use callback for this option.    description  string  Plain-text description of this type for clients (e.g. used by  GraphiQL  for auto-generated documentation)    interfaces  array  or  callback  returning  array  List of interfaces implemented by this type. See  Interface Types  for details. See also section on  Circular types  for explanation of when to use callback for this option.    isTypeOf  callback  returning  boolean  function($value, $context, GraphQL\\Type\\Definition\\ResolveInfo $info)  Expected to return  true  if  $value  qualifies for this type (see section about  Abstract Type Resolution  for explanation).    resolveField  callback  returning  mixed  function($value, $args, $context, GraphQL\\Type\\Definition\\ResolveInfo $info)  Given the  $value  of this type it is expected to return value for field defined in  $info- fieldName . Good place to define type-specific strategy for field resolution. See section on  Data Fetching  for details.", 
            "title": "Configuration options"
        }, 
        {
            "location": "/type-system/object-types/#field-configuration-options", 
            "text": "Below is a full list of available field configuration options:     Option  Type  Notes      name  string  Required.  Name of the field. When not set - inferred from  fields  array key (read about  shorthand field definition  below)    type  Type  Required.  Instance of internal or custom type. Note: type must be represented by single instance within schema (see also  Type Registry )    args  array  Array of possible type arguments. Each entry is expected to be an array with keys:  name ,  type ,  description ,  defaultValue . See  Field Arguments  section below.    resolve  callback  function($value, $args, $context, GraphQL\\Type\\Definition\\ResolveInfo $info)  Given the  $value  of this type it is expected to return value for current field. See section on  Data Fetching  for details    description  string  Plain-text description of this field for clients (e.g. used by  GraphiQL  for auto-generated documentation)    deprecationReason  string  Text describing why this field is deprecated. When not empty - field will not be returned by introspection queries (unless forced)", 
            "title": "Field configuration options"
        }, 
        {
            "location": "/type-system/object-types/#field-arguments", 
            "text": "Every field on a GraphQL object type can have zero or more arguments, defined in  args  option of field definition.\nEach argument is an array with following options:     Option  Type  Notes      name  string  Required.  Name of the argument. When not set - inferred from  args  array key    type  Type  Required.  Instance of one of  Input Types  ( scalar ,  enum ,  InputObjectType  + any combination of those with  nonNull  and  listOf  modifiers)    description  string  Plain-text description of this argument for clients (e.g. used by  GraphiQL  for auto-generated documentation)    defaultValue  scalar  Default value for this argument", 
            "title": "Field arguments"
        }, 
        {
            "location": "/type-system/object-types/#shorthand-field-definitions", 
            "text": "Fields can be also defined in  shorthand  notation (with only  name  and  type  options):  'fields' =  [\n    'id' =  Type::id(),\n    'fieldName' =  $fieldType\n]  which is equivalent of:  'fields' =  [\n    'id' =  ['type' =  Type::id()],\n    'fieldName' =  ['type' =  $fieldName]\n]  which is in turn equivalent of full form:  'fields' =  [\n    ['name' =  'id', 'type' =  Type::id()],\n    ['name' =  'fieldName', 'type' =  $fieldName]\n]  Same shorthand notation applies to field arguments as well.", 
            "title": "Shorthand field definitions"
        }, 
        {
            "location": "/type-system/object-types/#recurring-and-circular-types", 
            "text": "Almost all real-world applications contain recurring or circular types. \nThink user friends or nested comments for example.   graphql-php  allows such types, but you have to use  callback  in \noption  fields  (and/or  interfaces ).  For example:  $userType = null;\n\n$userType = new ObjectType([\n    'name' =  'User',\n    'fields' =  function() use ( $userType) {\n        return [\n            'email' =  [\n                'type' =  Type::string()\n            ],\n            'friends' =  [\n                'type' =  Type::listOf($userType)\n            ]\n        ];\n    }\n]);  Same example for  inheritance style of type definitions  using  TypeRegistry :  ?php\nnamespace MyApp;\n\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\nclass UserType extends ObjectType\n{\n    public function __construct()\n    {\n        $config = [\n            'fields' =  function() {\n                return [\n                    'email' =  MyTypes::string(),\n                    'friends' =  MyTypes::listOf(MyTypes::user())\n                ];\n            }\n        ];\n        parent::__construct($config);\n    }\n}\n\nclass MyTypes \n{\n    private static $user;\n\n    public static function user()\n    {\n        return self::$user ?: (self::$user = new UserType());\n    }\n\n    public static function string()\n    {\n        return Type::string();\n    }\n\n    public static function listOf($type)\n    {\n        return Type::listOf($type);\n    }\n}", 
            "title": "Recurring and circular types"
        }, 
        {
            "location": "/type-system/object-types/#field-resolution", 
            "text": "Field resolution is the primary mechanism in  graphql-php  for returning actual data for your fields.\nIt is implemented using  resolveField  callback in type definition or  resolve \ncallback in field definition (which has precedence).  Read section on  Data Fetching  for complete description of this process.", 
            "title": "Field Resolution"
        }, 
        {
            "location": "/type-system/object-types/#custom-metadata", 
            "text": "All types in  graphql-php  accept configuration array. In some cases you may be interested in \npassing your own metadata for type or field definition.  graphql-php  preserves original configuration array in every type or field instance in \npublic property  $config . Use it to implement app-level mappings and definitions.", 
            "title": "Custom Metadata"
        }, 
        {
            "location": "/type-system/scalar-types/", 
            "text": "Built-in Scalar Types\n\n\nGraphQL specification describes several built-in scalar types. In \ngraphql-php\n they are \nexposed as static methods of \nGraphQL\\Type\\Definition\\Type\n class:\n\n\nuse GraphQL\\Type\\Definition\\Type;\n\n// Built-in Scalar types:\nType::string();  // String type\nType::int();     // Int type\nType::float();   // Float type\nType::boolean(); // Boolean type\nType::id();      // ID type\n\n\n\n\nThose methods return instances of \nGraphQL\\Type\\Definition\\ScalarType\n (actually one of it subclasses).\nUse them directly in type definitions, or wrap in your \nTypeRegistry\n \n(if you use one).\n\n\nWriting Custom Scalar Types\n\n\nIn addition to built-in scalars, you can define your own scalar types with additional validation. \nTypical examples of such types are: \nEmail\n, \nDate\n, \nUrl\n, etc.\n\n\nIn order to implement your own type you must understand how scalars are presented in GraphQL.\nGraphQL deals with scalars in following cases:\n\n\n\n\n\n\nWhen converting \ninternal representation\n of value returned by your app (e.g. stored in database \nor hardcoded in source code) to \nserialized\n representation included in response.\n\n\n\n\n\n\nWhen converting \ninput value\n passed by client in variables along with GraphQL query to \n\ninternal representation\n of your app.\n\n\n\n\n\n\nWhen converting \ninput literal value\n hardcoded in GraphQL query (e.g. field argument value) to \n\ninternal representation\n of your app.\n\n\n\n\n\n\nThose cases are covered by methods \nserialize\n, \nparseValue\n and \nparseLiteral\n of abstract \nScalarType\n \nclass respectively.\n\n\nHere is an example of simple \nEmail\n type:\n\n\n?php\nnamespace MyApp;\n\nuse GraphQL\\Error\\Error;\nuse GraphQL\\Language\\AST\\StringValueNode;\nuse GraphQL\\Type\\Definition\\ScalarType;\nuse GraphQL\\Utils;\n\nclass EmailType extends ScalarType\n{\n    // Note: name can be omitted. In this case it will be inferred from class name \n    // (suffix \nType\n will be dropped)\n    public $name = 'Email';\n\n    /**\n     * Serializes an internal value to include in a response.\n     *\n     * @param string $value\n     * @return string\n     */\n    public function serialize($value)\n    {\n        // Assuming internal representation of email is always correct:\n        return $value;\n\n        // If it might be incorrect and you want to make sure that only correct values are included in response -\n        // use following line instead:\n        // return $this-\nparseValue($value);\n    }\n\n    /**\n     * Parses an externally provided value (query variable) to use as an input\n     *\n     * @param mixed $value\n     * @return mixed\n     */\n    public function parseValue($value)\n    {\n        if (!filter_var($value, FILTER_VALIDATE_EMAIL)) {\n            throw new \\UnexpectedValueException(\nCannot represent value as email: \n . Utils::printSafe($value));\n        }\n        return $value;\n    }\n\n    /**\n     * Parses an externally provided literal value (hardcoded in GraphQL query) to use as an input.\n     * \n     * E.g. \n     * {\n     *   user(email: \nuser@example.com\n) \n     * }\n     *\n     * @param \\GraphQL\\Language\\AST\\Node $valueNode\n     * @return string\n     * @throws Error\n     */\n    public function parseLiteral($valueNode)\n    {\n        // Note: throwing GraphQL\\Error\\Error vs \\UnexpectedValueException to benefit from GraphQL\n        // error location in query:\n        if (!$valueNode instanceof StringValueNode) {\n            throw new Error('Query error: Can only parse strings got: ' . $valueNode-\nkind, [$valueNode]);\n        }\n        if (!filter_var($valueNode-\nvalue, FILTER_VALIDATE_EMAIL)) {\n            throw new Error(\nNot a valid email\n, [$valueNode]);\n        }\n        return $valueNode-\nvalue;\n    }\n}\n\n\n\n\nOr with inline style:\n\n\n?php\nuse GraphQL\\Type\\Definition\\CustomScalarType;\n\n$emailType = new CustomScalarType([\n    'name' =\n 'Email',\n    'serialize' =\n function($value) {/* See function body above */},\n    'parseValue' =\n function($value) {/* See function body above */},\n    'parseLiteral' =\n function($valueNode) {/* See function body above */},\n]);", 
            "title": "Scalar Types"
        }, 
        {
            "location": "/type-system/scalar-types/#built-in-scalar-types", 
            "text": "GraphQL specification describes several built-in scalar types. In  graphql-php  they are \nexposed as static methods of  GraphQL\\Type\\Definition\\Type  class:  use GraphQL\\Type\\Definition\\Type;\n\n// Built-in Scalar types:\nType::string();  // String type\nType::int();     // Int type\nType::float();   // Float type\nType::boolean(); // Boolean type\nType::id();      // ID type  Those methods return instances of  GraphQL\\Type\\Definition\\ScalarType  (actually one of it subclasses).\nUse them directly in type definitions, or wrap in your  TypeRegistry  \n(if you use one).", 
            "title": "Built-in Scalar Types"
        }, 
        {
            "location": "/type-system/scalar-types/#writing-custom-scalar-types", 
            "text": "In addition to built-in scalars, you can define your own scalar types with additional validation. \nTypical examples of such types are:  Email ,  Date ,  Url , etc.  In order to implement your own type you must understand how scalars are presented in GraphQL.\nGraphQL deals with scalars in following cases:    When converting  internal representation  of value returned by your app (e.g. stored in database \nor hardcoded in source code) to  serialized  representation included in response.    When converting  input value  passed by client in variables along with GraphQL query to  internal representation  of your app.    When converting  input literal value  hardcoded in GraphQL query (e.g. field argument value) to  internal representation  of your app.    Those cases are covered by methods  serialize ,  parseValue  and  parseLiteral  of abstract  ScalarType  \nclass respectively.  Here is an example of simple  Email  type:  ?php\nnamespace MyApp;\n\nuse GraphQL\\Error\\Error;\nuse GraphQL\\Language\\AST\\StringValueNode;\nuse GraphQL\\Type\\Definition\\ScalarType;\nuse GraphQL\\Utils;\n\nclass EmailType extends ScalarType\n{\n    // Note: name can be omitted. In this case it will be inferred from class name \n    // (suffix  Type  will be dropped)\n    public $name = 'Email';\n\n    /**\n     * Serializes an internal value to include in a response.\n     *\n     * @param string $value\n     * @return string\n     */\n    public function serialize($value)\n    {\n        // Assuming internal representation of email is always correct:\n        return $value;\n\n        // If it might be incorrect and you want to make sure that only correct values are included in response -\n        // use following line instead:\n        // return $this- parseValue($value);\n    }\n\n    /**\n     * Parses an externally provided value (query variable) to use as an input\n     *\n     * @param mixed $value\n     * @return mixed\n     */\n    public function parseValue($value)\n    {\n        if (!filter_var($value, FILTER_VALIDATE_EMAIL)) {\n            throw new \\UnexpectedValueException( Cannot represent value as email:   . Utils::printSafe($value));\n        }\n        return $value;\n    }\n\n    /**\n     * Parses an externally provided literal value (hardcoded in GraphQL query) to use as an input.\n     * \n     * E.g. \n     * {\n     *   user(email:  user@example.com ) \n     * }\n     *\n     * @param \\GraphQL\\Language\\AST\\Node $valueNode\n     * @return string\n     * @throws Error\n     */\n    public function parseLiteral($valueNode)\n    {\n        // Note: throwing GraphQL\\Error\\Error vs \\UnexpectedValueException to benefit from GraphQL\n        // error location in query:\n        if (!$valueNode instanceof StringValueNode) {\n            throw new Error('Query error: Can only parse strings got: ' . $valueNode- kind, [$valueNode]);\n        }\n        if (!filter_var($valueNode- value, FILTER_VALIDATE_EMAIL)) {\n            throw new Error( Not a valid email , [$valueNode]);\n        }\n        return $valueNode- value;\n    }\n}  Or with inline style:  ?php\nuse GraphQL\\Type\\Definition\\CustomScalarType;\n\n$emailType = new CustomScalarType([\n    'name' =  'Email',\n    'serialize' =  function($value) {/* See function body above */},\n    'parseValue' =  function($value) {/* See function body above */},\n    'parseLiteral' =  function($valueNode) {/* See function body above */},\n]);", 
            "title": "Writing Custom Scalar Types"
        }, 
        {
            "location": "/type-system/enum-types/", 
            "text": "Enum Type Definition\n\n\nEnumeration types are a special kind of scalar that is restricted to a particular set \nof allowed values. \n\n\nIn \ngraphql-php\n enum type is an instance of \nGraphQL\\Type\\Definition\\EnumType\n \n(or one of it subclasses) which accepts configuration array in constructor:\n\n\nuse GraphQL\\Type\\Definition\\EnumType;\n\n$episodeEnum = new EnumType([\n    'name' =\n 'Episode',\n    'description' =\n 'One of the films in the Star Wars Trilogy',\n    'values' =\n [\n        'NEWHOPE' =\n [\n            'value' =\n 4,\n            'description' =\n 'Released in 1977.'\n        ],\n        'EMPIRE' =\n [\n            'value' =\n 5,\n            'description' =\n 'Released in 1980.'\n        ],\n        'JEDI' =\n [\n            'value' =\n 6,\n            'description' =\n 'Released in 1983.'\n        ],\n    ]\n]);\n\n\n\n\nThis example uses \ninline\n style for Enum Type definition, but you can also use\n\ninheritance\n.\n\n\nConfiguration options\n\n\nEnum Type constructor accepts array with following options:\n\n\n\n\n\n\n\n\nOption\n\n\nType\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nname\n\n\nstring\n\n\nRequired.\n Name of the type. When not set - inferred from array key (read about \nshorthand field definition\n below)\n\n\n\n\n\n\ndescription\n\n\nstring\n\n\nPlain-text description of the type for clients (e.g. used by \nGraphiQL\n for auto-generated documentation)\n\n\n\n\n\n\nvalues\n\n\narray\n\n\nList of enumerated items, see below for expected structure of each entry\n\n\n\n\n\n\n\n\nEach entry of \nvalues\n array in turn accepts following options:\n\n\n\n\n\n\n\n\nOption\n\n\nType\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nname\n\n\nstring\n\n\nRequired.\n Name of the item. When not set - inferred from array key (read about \nshorthand field definition\n below)\n\n\n\n\n\n\nvalue\n\n\nmixed\n\n\nInternal representation of enum item in your application (could be any value, including complex objects or callbacks)\n\n\n\n\n\n\ndescription\n\n\nstring\n\n\nPlain-text description of enum value for clients (e.g. used by \nGraphiQL\n for auto-generated documentation)\n\n\n\n\n\n\ndeprecationReason\n\n\nstring\n\n\nText describing why this enum value is deprecated. When not empty - item will not be returned by introspection queries (unless forced)\n\n\n\n\n\n\n\n\nShorthand definitions\n\n\nIf internal representation of enumerated item is the same as item name, then you can use\nfollowing shorthand for definition:\n\n\n$episodeEnum = new EnumType([\n    'name' =\n 'Episode',\n    'description' =\n 'One of the films in the Star Wars Trilogy',\n    'values' =\n ['NEWHOPE', 'EMPIRE', 'JEDI']\n]);\n\n\n\n\nwhich is equivalent of:\n\n\n$episodeEnum = new EnumType([\n    'name' =\n 'Episode',\n    'description' =\n 'One of the films in the Star Wars Trilogy',\n    'values' =\n [\n        'NEWHOPE' =\n 'NEWHOPE', \n        'EMPIRE' =\n 'EMPIRE', \n        'JEDI' =\n 'JEDI'\n    ]\n]);\n\n\n\n\nwhich is in turn equivalent of:\n\n\n$episodeEnum = new EnumType([\n    'name' =\n 'Episode',\n    'description' =\n 'One of the films in the Star Wars Trilogy',\n    'values' =\n [\n        'NEWHOPE' =\n ['value' =\n 'NEWHOPE'], \n        'EMPIRE' =\n ['value' =\n 'EMPIRE'], \n        'JEDI' =\n ['value' =\n 'JEDI']\n    ]\n]);\n\n\n\n\nwhich is in turn equivalent of full form:\n\n\n$episodeEnum = new EnumType([\n    'name' =\n 'Episode',\n    'description' =\n 'One of the films in the Star Wars Trilogy',\n    'values' =\n [\n        ['name' =\n 'NEWHOPE', 'value' =\n 'NEWHOPE'], \n        ['name' =\n 'EMPIRE', 'value' =\n 'EMPIRE'], \n        ['name' =\n 'JEDI', 'value' =\n 'JEDI']\n    ]\n]);\n\n\n\n\nField Resolution\n\n\nWhen object field is of Enum Type, field resolver is expected to return internal \nrepresentation of corresponding Enum item (\nvalue\n in config). \ngraphql-php\n will \nthen serialize this \nvalue\n to \nname\n to include in response:\n\n\nuse GraphQL\\Type\\Definition\\EnumType;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$episodeEnum = new EnumType([\n    'name' =\n 'Episode',\n    'description' =\n 'One of the films in the Star Wars Trilogy',\n    'values' =\n [\n        'NEWHOPE' =\n [\n            'value' =\n 4,\n            'description' =\n 'Released in 1977.'\n        ],\n        'EMPIRE' =\n [\n            'value' =\n 5,\n            'description' =\n 'Released in 1980.'\n        ],\n        'JEDI' =\n [\n            'value' =\n 6,\n            'description' =\n 'Released in 1983.'\n        ],\n    ]\n]);\n\n$heroType = new ObjectType([\n    'name' =\n 'Hero',\n    'fields' =\n [\n        'appearsIn' =\n [\n            'type' =\n $episodeEnum,\n            'resolve' =\n function() {\n                return 5; // Actual entry in response will be 'appearsIn' =\n 'EMPIRE'\n            }\n        ]\n    ]\n])\n\n\n\n\nReverse is true when enum is used as input type (e.g. as field argument). \nGraphQL will treat enum input as \nname\n and convert it into \nvalue\n before passing to your app.\n\n\nFor example, given object type definition:\n\n\n$heroType = new ObjectType([\n    'name' =\n 'Hero',\n    'fields' =\n [\n        'appearsIn' =\n [\n            'type' =\n Type::boolean(),\n            'args' =\n [\n                'episode' =\n Type::nonNull($enumType)\n            ]\n            'resolve' =\n function($_value, $args) {\n                return $args['episode'] === 5 ? true : false; \n            }\n        ]\n    ]\n])\n\n\n\n\nThen following query:\n\n\nfragment on Hero {\n    appearsInNewHope: appearsIn(NEWHOPE)\n    appearsInEmpire: appearsIn(EMPIRE)\n}\n\n\n\n\nwill return:\n\n\n[\n    'appearsInNewHope' =\n false,\n    'appearsInEmpire' =\n true\n]", 
            "title": "Enumeration Types"
        }, 
        {
            "location": "/type-system/enum-types/#enum-type-definition", 
            "text": "Enumeration types are a special kind of scalar that is restricted to a particular set \nof allowed values.   In  graphql-php  enum type is an instance of  GraphQL\\Type\\Definition\\EnumType  \n(or one of it subclasses) which accepts configuration array in constructor:  use GraphQL\\Type\\Definition\\EnumType;\n\n$episodeEnum = new EnumType([\n    'name' =  'Episode',\n    'description' =  'One of the films in the Star Wars Trilogy',\n    'values' =  [\n        'NEWHOPE' =  [\n            'value' =  4,\n            'description' =  'Released in 1977.'\n        ],\n        'EMPIRE' =  [\n            'value' =  5,\n            'description' =  'Released in 1980.'\n        ],\n        'JEDI' =  [\n            'value' =  6,\n            'description' =  'Released in 1983.'\n        ],\n    ]\n]);  This example uses  inline  style for Enum Type definition, but you can also use inheritance .", 
            "title": "Enum Type Definition"
        }, 
        {
            "location": "/type-system/enum-types/#configuration-options", 
            "text": "Enum Type constructor accepts array with following options:     Option  Type  Notes      name  string  Required.  Name of the type. When not set - inferred from array key (read about  shorthand field definition  below)    description  string  Plain-text description of the type for clients (e.g. used by  GraphiQL  for auto-generated documentation)    values  array  List of enumerated items, see below for expected structure of each entry     Each entry of  values  array in turn accepts following options:     Option  Type  Notes      name  string  Required.  Name of the item. When not set - inferred from array key (read about  shorthand field definition  below)    value  mixed  Internal representation of enum item in your application (could be any value, including complex objects or callbacks)    description  string  Plain-text description of enum value for clients (e.g. used by  GraphiQL  for auto-generated documentation)    deprecationReason  string  Text describing why this enum value is deprecated. When not empty - item will not be returned by introspection queries (unless forced)", 
            "title": "Configuration options"
        }, 
        {
            "location": "/type-system/enum-types/#shorthand-definitions", 
            "text": "If internal representation of enumerated item is the same as item name, then you can use\nfollowing shorthand for definition:  $episodeEnum = new EnumType([\n    'name' =  'Episode',\n    'description' =  'One of the films in the Star Wars Trilogy',\n    'values' =  ['NEWHOPE', 'EMPIRE', 'JEDI']\n]);  which is equivalent of:  $episodeEnum = new EnumType([\n    'name' =  'Episode',\n    'description' =  'One of the films in the Star Wars Trilogy',\n    'values' =  [\n        'NEWHOPE' =  'NEWHOPE', \n        'EMPIRE' =  'EMPIRE', \n        'JEDI' =  'JEDI'\n    ]\n]);  which is in turn equivalent of:  $episodeEnum = new EnumType([\n    'name' =  'Episode',\n    'description' =  'One of the films in the Star Wars Trilogy',\n    'values' =  [\n        'NEWHOPE' =  ['value' =  'NEWHOPE'], \n        'EMPIRE' =  ['value' =  'EMPIRE'], \n        'JEDI' =  ['value' =  'JEDI']\n    ]\n]);  which is in turn equivalent of full form:  $episodeEnum = new EnumType([\n    'name' =  'Episode',\n    'description' =  'One of the films in the Star Wars Trilogy',\n    'values' =  [\n        ['name' =  'NEWHOPE', 'value' =  'NEWHOPE'], \n        ['name' =  'EMPIRE', 'value' =  'EMPIRE'], \n        ['name' =  'JEDI', 'value' =  'JEDI']\n    ]\n]);", 
            "title": "Shorthand definitions"
        }, 
        {
            "location": "/type-system/enum-types/#field-resolution", 
            "text": "When object field is of Enum Type, field resolver is expected to return internal \nrepresentation of corresponding Enum item ( value  in config).  graphql-php  will \nthen serialize this  value  to  name  to include in response:  use GraphQL\\Type\\Definition\\EnumType;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$episodeEnum = new EnumType([\n    'name' =  'Episode',\n    'description' =  'One of the films in the Star Wars Trilogy',\n    'values' =  [\n        'NEWHOPE' =  [\n            'value' =  4,\n            'description' =  'Released in 1977.'\n        ],\n        'EMPIRE' =  [\n            'value' =  5,\n            'description' =  'Released in 1980.'\n        ],\n        'JEDI' =  [\n            'value' =  6,\n            'description' =  'Released in 1983.'\n        ],\n    ]\n]);\n\n$heroType = new ObjectType([\n    'name' =  'Hero',\n    'fields' =  [\n        'appearsIn' =  [\n            'type' =  $episodeEnum,\n            'resolve' =  function() {\n                return 5; // Actual entry in response will be 'appearsIn' =  'EMPIRE'\n            }\n        ]\n    ]\n])  Reverse is true when enum is used as input type (e.g. as field argument). \nGraphQL will treat enum input as  name  and convert it into  value  before passing to your app.  For example, given object type definition:  $heroType = new ObjectType([\n    'name' =  'Hero',\n    'fields' =  [\n        'appearsIn' =  [\n            'type' =  Type::boolean(),\n            'args' =  [\n                'episode' =  Type::nonNull($enumType)\n            ]\n            'resolve' =  function($_value, $args) {\n                return $args['episode'] === 5 ? true : false; \n            }\n        ]\n    ]\n])  Then following query:  fragment on Hero {\n    appearsInNewHope: appearsIn(NEWHOPE)\n    appearsInEmpire: appearsIn(EMPIRE)\n}  will return:  [\n    'appearsInNewHope' =  false,\n    'appearsInEmpire' =  true\n]", 
            "title": "Field Resolution"
        }, 
        {
            "location": "/type-system/lists-and-nonnulls/", 
            "text": "Lists\n\n\ngraphql-php\n provides built-in support for lists. In order to create list type - wrap \nexisting type with \nGraphQL\\Type\\Definition\\Type::listOf()\n modifier:\n\n\n?php\nnamespace MyApp;\n\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$userType = new ObjectType([\n    'name' =\n 'User',\n    'fields' =\n [\n        'emails' =\n [\n            'type' =\n Type::listOf(Type::string()),\n            'resolve' =\n function() {\n                return ['jon@example.com', 'jonny@example.com'];\n            }\n        ]\n    ]\n]);\n\n\n\n\nResolvers for such fields are expected to return \narray\n or instance of PHP internal \nTraversable\n \ninterface (\nnull\n is allowed by default too). \n\n\nIf returned value is not of one of these types - \ngraphql-php\n will add an error to result \nand set field value to \nnull\n (only if field is nullable, see below for non-null fields).\n\n\nNon-Null fields\n\n\nBy default in GraphQL every field can have \nnull\n value. To indicate that some field always \nreturns \nnon-null\n value - use \nGraphQL\\Type\\Definition\\Type::nonNull()\n modifier:\n\n\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$humanType = new ObjectType([\n    'name' =\n 'User',\n    'fields' =\n [\n        'id' =\n [\n            'type' =\n Type::nonNull(Type::id()),\n            'resolve' =\n function() {\n                return uniqid();\n            }\n        ],\n        'emails' =\n [\n            'type' =\n Type::nonNull(Type::listOf(Type::string())),\n            'resolve' =\n function() {\n                return ['jon@example.com', 'jonny@example.com'];\n            }\n        ]\n    ]\n]);\n\n\n\n\nIf resolver of non-null field returns \nnull\n, \ngraphql-php\n will add an error to \nresult and exclude whole object from output (error will bubble to first nullable parent \nfield which will be set to \nnull\n).\n\n\nRead section on \nData Fetching\n for details.", 
            "title": "Lists and Non-Null"
        }, 
        {
            "location": "/type-system/lists-and-nonnulls/#lists", 
            "text": "graphql-php  provides built-in support for lists. In order to create list type - wrap \nexisting type with  GraphQL\\Type\\Definition\\Type::listOf()  modifier:  ?php\nnamespace MyApp;\n\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$userType = new ObjectType([\n    'name' =  'User',\n    'fields' =  [\n        'emails' =  [\n            'type' =  Type::listOf(Type::string()),\n            'resolve' =  function() {\n                return ['jon@example.com', 'jonny@example.com'];\n            }\n        ]\n    ]\n]);  Resolvers for such fields are expected to return  array  or instance of PHP internal  Traversable  \ninterface ( null  is allowed by default too).   If returned value is not of one of these types -  graphql-php  will add an error to result \nand set field value to  null  (only if field is nullable, see below for non-null fields).", 
            "title": "Lists"
        }, 
        {
            "location": "/type-system/lists-and-nonnulls/#non-null-fields", 
            "text": "By default in GraphQL every field can have  null  value. To indicate that some field always \nreturns  non-null  value - use  GraphQL\\Type\\Definition\\Type::nonNull()  modifier:  use GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$humanType = new ObjectType([\n    'name' =  'User',\n    'fields' =  [\n        'id' =  [\n            'type' =  Type::nonNull(Type::id()),\n            'resolve' =  function() {\n                return uniqid();\n            }\n        ],\n        'emails' =  [\n            'type' =  Type::nonNull(Type::listOf(Type::string())),\n            'resolve' =  function() {\n                return ['jon@example.com', 'jonny@example.com'];\n            }\n        ]\n    ]\n]);  If resolver of non-null field returns  null ,  graphql-php  will add an error to \nresult and exclude whole object from output (error will bubble to first nullable parent \nfield which will be set to  null ).  Read section on  Data Fetching  for details.", 
            "title": "Non-Null fields"
        }, 
        {
            "location": "/type-system/interfaces/", 
            "text": "Interface Type Definition\n\n\nAn Interface is an abstract type that includes a certain set of fields that a \ntype must include to implement the interface.\n\n\nIn \ngraphql-php\n interface type is an instance of \nGraphQL\\Type\\Definition\\InterfaceType\n \n(or one of it subclasses) which accepts configuration array in constructor:\n\n\nuse GraphQL\\Type\\Definition\\InterfaceType;\nuse GraphQL\\Type\\Definition\\Type;\n\n$character = new InterfaceType([\n    'name' =\n 'Character',\n    'description' =\n 'A character in the Star Wars Trilogy',\n    'fields' =\n [\n        'id' =\n [\n            'type' =\n Type::nonNull(Type::string()),\n            'description' =\n 'The id of the character.',\n        ],\n        'name' =\n [\n            'type' =\n Type::string(),\n            'description' =\n 'The name of the character.'\n        ]\n    ],\n    'resolveType' =\n function ($value) {\n        if ($value-\ntype === 'human') {\n            return MyTypes::human();            \n        } else {\n            return MyTypes::droid();\n        }\n    }\n]);\n\n\n\n\nThis example uses \ninline\n style for Interface definition, but you can also use\n\n\ninheritance\n.\n\n\nConfiguration options\n\n\nConstructor of InterfaceType accepts an array. Below is a full list of allowed options:\n\n\n\n\n\n\n\n\nOption\n\n\nType\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nname\n\n\nstring\n\n\nRequired.\n Unique name of this interface type within Schema\n\n\n\n\n\n\nfields\n\n\narray\n\n\nRequired.\n List of fields required to be defined by interface implementors. Same as \nFields for Object Type\n\n\n\n\n\n\ndescription\n\n\nstring\n\n\nPlain-text description of this type for clients (e.g. used by \nGraphiQL\n for auto-generated documentation)\n\n\n\n\n\n\nresolveType\n\n\ncallback\n returning instance of \nObjectType\n\n\nfunction($value, $context, GraphQL\\Type\\Definition\\ResolveInfo $info)\n Any \ncallable\n that receives \n$value\n from resolver of the parent field and returns concrete interface implementor for that \n$value\n.\n\n\n\n\n\n\n\n\nImplementing interface\n\n\nTo implement the Interface simply add it to \ninterfaces\n array of Object Type definition:\n\n\n$humanType = new ObjectType([\n    'name' =\n 'Human',\n    'fields' =\n [\n        'id' =\n [\n            'type' =\n Type::nonNull(Type::string()),\n            'description' =\n 'The id of the character.',\n        ],\n        'name' =\n [\n            'type' =\n Type::string(),\n            'description' =\n 'The name of the character.'\n        ]\n    ],\n    'interfaces' =\n [\n        $character\n    ]\n]);\n\n\n\n\nNote that Object Type must include all fields of interface with exact same types \n(including \nnonNull\n specification) and arguments.\n\n\nThe only exception is when object's field type is more specific than the type of this field defined in interface \n(see \nCovariant return types for interface fields\n below)\n\n\nCovariant return types for interface fields\n\n\nObject types implementing interface may change field type to more specific.\nExample:\n\n\ninterface A {\n  field1: A\n}\n\ntype B implements A {\n  field1: B\n}\n\n\n\n\nSharing Interface fields\n\n\nSince every Object Type implementing an Interface must have the same set of fields - it often makes \nsense to re-use field definitions of Interface in Object Types:\n\n\n$humanType = new ObjectType([\n    'name' =\n 'Human',\n    'interfaces' =\n [\n        $character\n    ],\n    'fields' =\n [\n        'height' =\n Type::float(),\n        $character-\ngetField('id'),\n        $character-\ngetField('name')\n    ] \n]);\n\n\n\n\nIn this case field definitions are created only once (as a part of Interface Type) and then \nre-used by all interface implementors. It can save several microseconds and kilobytes + ensures that \nfield definitions of Interface and implementors are always in sync.\n\n\nYet it creates a problem with resolution of such fields. There are two ways how shared fields could \nbe resolved:\n\n\n\n\n\n\nIf field resolution algorithm is the same for all Interface implementors - you can simply add \n\nresolve\n option to field definition in Interface itself.\n\n\n\n\n\n\nIf field resolution varies from implementor to implementor - you can specify \nresolveField\n \noption in \nObject Type config\n and handle field \nresolutions there \n(Note: \nresolve\n option in field definition has precedence over \nresolveField\n option in object type definition)\n\n\n\n\n\n\nInterface role in data fetching\n\n\nThe only responsibility of interface in Data Fetching process is to return concrete Object Type \nfor given \n$value\n in \nresolveType\n. Then resolution of fields is delegated to resolvers of this \nconcrete Object Type.\n\n\nIf \nresolveType\n option is omitted, \ngraphql-php\n will loop through all interface implementors and \nuse their \nisTypeOf\n callback to pick the first suitable one. This is obviously less efficient \nthan single \nresolveType\n call. So it is recommended to define \nresolveType\n whenever possible.", 
            "title": "Interfaces"
        }, 
        {
            "location": "/type-system/interfaces/#interface-type-definition", 
            "text": "An Interface is an abstract type that includes a certain set of fields that a \ntype must include to implement the interface.  In  graphql-php  interface type is an instance of  GraphQL\\Type\\Definition\\InterfaceType  \n(or one of it subclasses) which accepts configuration array in constructor:  use GraphQL\\Type\\Definition\\InterfaceType;\nuse GraphQL\\Type\\Definition\\Type;\n\n$character = new InterfaceType([\n    'name' =  'Character',\n    'description' =  'A character in the Star Wars Trilogy',\n    'fields' =  [\n        'id' =  [\n            'type' =  Type::nonNull(Type::string()),\n            'description' =  'The id of the character.',\n        ],\n        'name' =  [\n            'type' =  Type::string(),\n            'description' =  'The name of the character.'\n        ]\n    ],\n    'resolveType' =  function ($value) {\n        if ($value- type === 'human') {\n            return MyTypes::human();            \n        } else {\n            return MyTypes::droid();\n        }\n    }\n]);  This example uses  inline  style for Interface definition, but you can also use  inheritance .", 
            "title": "Interface Type Definition"
        }, 
        {
            "location": "/type-system/interfaces/#configuration-options", 
            "text": "Constructor of InterfaceType accepts an array. Below is a full list of allowed options:     Option  Type  Notes      name  string  Required.  Unique name of this interface type within Schema    fields  array  Required.  List of fields required to be defined by interface implementors. Same as  Fields for Object Type    description  string  Plain-text description of this type for clients (e.g. used by  GraphiQL  for auto-generated documentation)    resolveType  callback  returning instance of  ObjectType  function($value, $context, GraphQL\\Type\\Definition\\ResolveInfo $info)  Any  callable  that receives  $value  from resolver of the parent field and returns concrete interface implementor for that  $value .", 
            "title": "Configuration options"
        }, 
        {
            "location": "/type-system/interfaces/#implementing-interface", 
            "text": "To implement the Interface simply add it to  interfaces  array of Object Type definition:  $humanType = new ObjectType([\n    'name' =  'Human',\n    'fields' =  [\n        'id' =  [\n            'type' =  Type::nonNull(Type::string()),\n            'description' =  'The id of the character.',\n        ],\n        'name' =  [\n            'type' =  Type::string(),\n            'description' =  'The name of the character.'\n        ]\n    ],\n    'interfaces' =  [\n        $character\n    ]\n]);  Note that Object Type must include all fields of interface with exact same types \n(including  nonNull  specification) and arguments.  The only exception is when object's field type is more specific than the type of this field defined in interface \n(see  Covariant return types for interface fields  below)", 
            "title": "Implementing interface"
        }, 
        {
            "location": "/type-system/interfaces/#covariant-return-types-for-interface-fields", 
            "text": "Object types implementing interface may change field type to more specific.\nExample:  interface A {\n  field1: A\n}\n\ntype B implements A {\n  field1: B\n}", 
            "title": "Covariant return types for interface fields"
        }, 
        {
            "location": "/type-system/interfaces/#sharing-interface-fields", 
            "text": "Since every Object Type implementing an Interface must have the same set of fields - it often makes \nsense to re-use field definitions of Interface in Object Types:  $humanType = new ObjectType([\n    'name' =  'Human',\n    'interfaces' =  [\n        $character\n    ],\n    'fields' =  [\n        'height' =  Type::float(),\n        $character- getField('id'),\n        $character- getField('name')\n    ] \n]);  In this case field definitions are created only once (as a part of Interface Type) and then \nre-used by all interface implementors. It can save several microseconds and kilobytes + ensures that \nfield definitions of Interface and implementors are always in sync.  Yet it creates a problem with resolution of such fields. There are two ways how shared fields could \nbe resolved:    If field resolution algorithm is the same for all Interface implementors - you can simply add  resolve  option to field definition in Interface itself.    If field resolution varies from implementor to implementor - you can specify  resolveField  \noption in  Object Type config  and handle field \nresolutions there \n(Note:  resolve  option in field definition has precedence over  resolveField  option in object type definition)", 
            "title": "Sharing Interface fields"
        }, 
        {
            "location": "/type-system/interfaces/#interface-role-in-data-fetching", 
            "text": "The only responsibility of interface in Data Fetching process is to return concrete Object Type \nfor given  $value  in  resolveType . Then resolution of fields is delegated to resolvers of this \nconcrete Object Type.  If  resolveType  option is omitted,  graphql-php  will loop through all interface implementors and \nuse their  isTypeOf  callback to pick the first suitable one. This is obviously less efficient \nthan single  resolveType  call. So it is recommended to define  resolveType  whenever possible.", 
            "title": "Interface role in data fetching"
        }, 
        {
            "location": "/type-system/unions/", 
            "text": "Union Type Definition\n\n\nA Union is an abstract type that simply enumerates other Object Types. \nValue of Union Type is actually a value of one of included Object Types.\n\n\nIn \ngraphql-php\n union type is an instance of \nGraphQL\\Type\\Definition\\UnionType\n \n(or one of it subclasses) which accepts configuration array in constructor:\n\n\n$searchResultType = new UnionType([\n    'name' =\n 'SearchResult',\n    'types' =\n [\n        MyTypes::story(),\n        MyTypes::user()\n    ];\n    'resolveType' =\n function($value) {\n        if ($value-\ntype === 'story') {\n            return MyTypes::story();            \n        } else {\n            return MyTypes::user();\n        }\n    }\n]);\n\n\n\n\nThis example uses \ninline\n style for Union definition, but you can also use\n\n\ninheritance\n.\n\n\nConfiguration options\n\n\nConstructor of UnionType accepts an array. Below is a full list of allowed options:\n\n\n\n\n\n\n\n\nOption\n\n\nType\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nname\n\n\nstring\n\n\nRequired.\n Unique name of this interface type within Schema\n\n\n\n\n\n\ntypes\n\n\narray\n\n\nRequired.\n List of Object Types included in this Union. Note that you can't create a Union type out of Interfaces or other Unions.\n\n\n\n\n\n\ndescription\n\n\nstring\n\n\nPlain-text description of this type for clients (e.g. used by \nGraphiQL\n for auto-generated documentation)\n\n\n\n\n\n\nresolveType\n\n\ncallback\n returning instance of \nObjectType\n\n\nfunction($value, $context, GraphQL\\Type\\Definition\\ResolveInfo $info)\n Any \ncallable\n that receives \n$value\n from resolver of the parent field and returns Object Type for that \n$value\n.", 
            "title": "Unions"
        }, 
        {
            "location": "/type-system/unions/#union-type-definition", 
            "text": "A Union is an abstract type that simply enumerates other Object Types. \nValue of Union Type is actually a value of one of included Object Types.  In  graphql-php  union type is an instance of  GraphQL\\Type\\Definition\\UnionType  \n(or one of it subclasses) which accepts configuration array in constructor:  $searchResultType = new UnionType([\n    'name' =  'SearchResult',\n    'types' =  [\n        MyTypes::story(),\n        MyTypes::user()\n    ];\n    'resolveType' =  function($value) {\n        if ($value- type === 'story') {\n            return MyTypes::story();            \n        } else {\n            return MyTypes::user();\n        }\n    }\n]);  This example uses  inline  style for Union definition, but you can also use  inheritance .", 
            "title": "Union Type Definition"
        }, 
        {
            "location": "/type-system/unions/#configuration-options", 
            "text": "Constructor of UnionType accepts an array. Below is a full list of allowed options:     Option  Type  Notes      name  string  Required.  Unique name of this interface type within Schema    types  array  Required.  List of Object Types included in this Union. Note that you can't create a Union type out of Interfaces or other Unions.    description  string  Plain-text description of this type for clients (e.g. used by  GraphiQL  for auto-generated documentation)    resolveType  callback  returning instance of  ObjectType  function($value, $context, GraphQL\\Type\\Definition\\ResolveInfo $info)  Any  callable  that receives  $value  from resolver of the parent field and returns Object Type for that  $value .", 
            "title": "Configuration options"
        }, 
        {
            "location": "/type-system/input-types/", 
            "text": "About Input and Output Types\n\n\nGraphQL receives data from clients via \nField Arguments\n.\n\n\nBoth - fields and arguments require \ntype\n option in definition. But expected value of this option\nis different for fields and arguments, as in GraphQL argument is conceptually input while field is conceptually \noutput.\n\n\nConsequentially all types in GraphQL are of two categories: \ninput\n and \noutput\n.\n\n\n\n\n\n\nOutput\n types (or field types) are: \nScalar\n, \nEnum\n, \nObject\n, \n\nInterface\n, \nUnion\n\n\n\n\n\n\nInput\n types (or argument types) are: \nScalar\n, \nEnum\n, InputObject\n\n\n\n\n\n\nObviously \nNonNull and List\n types belong to both categories depending on their \ninner type.\n\n\nUntil now all examples of field \narguments\n in this documentation were of \nScalar\n or \n\nEnum\n types. But you can also easily pass complex objects. \n\n\nThis is particularly valuable in the case of mutations, where input data might be rather complex.\n\n\nInput Object Type\n\n\nGraphQL specification defines Input Object Type for complex inputs. It is similar to ObjectType\nexcept that it's fields have no \nargs\n or \nresolve\n options and their \ntype\n must be input type.\n\n\nIn \ngraphql-php\n Input Object Type is an instance of \nGraphQL\\Type\\Definition\\InputObjectType\n \n(or one of it subclasses) which accepts configuration array in constructor:\n\n\n$filters = new InputObjectType([\n    'name' =\n 'StoryFiltersInput',\n    'fields' =\n [\n        'author' =\n [\n            'type' =\n Type::id(),\n            'description' =\n 'Only show stories with this author id'\n        ],\n        'popular' =\n [\n            'type' =\n Type::boolean(),\n            'description' =\n 'Only show popular stories (liked by several people)'\n        ],\n        'tags' =\n [\n            'type' =\n Type::listOf(Type::string()),\n            'description' =\n 'Only show stories which contain all of those tags'\n        ]\n    ]\n]);\n\n\n\n\nEvery field may be of other InputObjectType (thus complex hierarchies of inputs are possible)\n\n\nConfiguration options\n\n\nConstructor of InputObjectType accepts array with only 3 options:\n\n\n\n\n\n\n\n\nOption\n\n\nType\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nname\n\n\nstring\n\n\nRequired.\n Unique name of this object type within Schema\n\n\n\n\n\n\nfields\n\n\narray\n or \ncallback\n returning \narray\n\n\nRequired\n. Array describing object fields (see below).\n\n\n\n\n\n\ndescription\n\n\nstring\n\n\nPlain-text description of this type for clients (e.g. used by \nGraphiQL\n for auto-generated documentation)\n\n\n\n\n\n\n\n\nEvery field is an array with following entries:\n\n\n\n\n\n\n\n\nOption\n\n\nType\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nname\n\n\nstring\n\n\nRequired.\n Name of the input field. When not set - inferred from \nfields\n array key\n\n\n\n\n\n\ntype\n\n\nType\n\n\nRequired.\n Instance of one of \nInput Types\n (\nScalar\n, \nEnum\n, \nInputObjectType\n + any combination of those with \nNonNull\n and \nList\n modifiers)\n\n\n\n\n\n\ndescription\n\n\nstring\n\n\nPlain-text description of this input field for clients (e.g. used by \nGraphiQL\n for auto-generated documentation)\n\n\n\n\n\n\ndefaultValue\n\n\nscalar\n\n\nDefault value of this input field\n\n\n\n\n\n\n\n\nUsing Input Object Type\n\n\nIn the example above we defined our InputObjectType. Now let's use it in one of field arguments:\n\n\n$queryType = new ObjectType([\n    'name' =\n 'Query',\n    'fields' =\n [\n        'stories' =\n [\n            'type' =\n Type::listOf($storyType),\n            'args' =\n [\n                'filters' =\n [\n                    'type' =\n Type::nonNull($filters),\n                    'defaultValue' =\n [\n                        'popular' =\n true\n                    ]\n                ]\n            ],\n            'resolve' =\n function($rootValue, $args) {\n                return DataSource::filterStories($args['filters']);\n            }\n        ]\n    ]\n]);\n\n\n\n\n(note that you can define \ndefaultValue\n for fields with complex inputs as associative array).\n\n\nThen GraphQL query could include filters as literal value:\n\n\n{\n    stories(filters: {author: \n1\n, popular: false})\n}\n\n\n\n\nOr as query variable:\n\n\nquery($filters: StoryFiltersInput!) {\n    stories(filters: $filters)\n}\n\n\n\n\n$variables = [\n    'filters' =\n [\n        \nauthor\n =\n \n1\n,\n        \npopular\n =\n false\n    ]\n];\n\n\n\n\ngraphql-php\n will validate the input against your InputObjectType definition and pass it to your \nresolver as \n$args['filters']", 
            "title": "Input Types"
        }, 
        {
            "location": "/type-system/input-types/#about-input-and-output-types", 
            "text": "GraphQL receives data from clients via  Field Arguments .  Both - fields and arguments require  type  option in definition. But expected value of this option\nis different for fields and arguments, as in GraphQL argument is conceptually input while field is conceptually \noutput.  Consequentially all types in GraphQL are of two categories:  input  and  output .    Output  types (or field types) are:  Scalar ,  Enum ,  Object ,  Interface ,  Union    Input  types (or argument types) are:  Scalar ,  Enum , InputObject    Obviously  NonNull and List  types belong to both categories depending on their \ninner type.  Until now all examples of field  arguments  in this documentation were of  Scalar  or  Enum  types. But you can also easily pass complex objects.   This is particularly valuable in the case of mutations, where input data might be rather complex.", 
            "title": "About Input and Output Types"
        }, 
        {
            "location": "/type-system/input-types/#input-object-type", 
            "text": "GraphQL specification defines Input Object Type for complex inputs. It is similar to ObjectType\nexcept that it's fields have no  args  or  resolve  options and their  type  must be input type.  In  graphql-php  Input Object Type is an instance of  GraphQL\\Type\\Definition\\InputObjectType  \n(or one of it subclasses) which accepts configuration array in constructor:  $filters = new InputObjectType([\n    'name' =  'StoryFiltersInput',\n    'fields' =  [\n        'author' =  [\n            'type' =  Type::id(),\n            'description' =  'Only show stories with this author id'\n        ],\n        'popular' =  [\n            'type' =  Type::boolean(),\n            'description' =  'Only show popular stories (liked by several people)'\n        ],\n        'tags' =  [\n            'type' =  Type::listOf(Type::string()),\n            'description' =  'Only show stories which contain all of those tags'\n        ]\n    ]\n]);  Every field may be of other InputObjectType (thus complex hierarchies of inputs are possible)", 
            "title": "Input Object Type"
        }, 
        {
            "location": "/type-system/input-types/#configuration-options", 
            "text": "Constructor of InputObjectType accepts array with only 3 options:     Option  Type  Notes      name  string  Required.  Unique name of this object type within Schema    fields  array  or  callback  returning  array  Required . Array describing object fields (see below).    description  string  Plain-text description of this type for clients (e.g. used by  GraphiQL  for auto-generated documentation)     Every field is an array with following entries:     Option  Type  Notes      name  string  Required.  Name of the input field. When not set - inferred from  fields  array key    type  Type  Required.  Instance of one of  Input Types  ( Scalar ,  Enum ,  InputObjectType  + any combination of those with  NonNull  and  List  modifiers)    description  string  Plain-text description of this input field for clients (e.g. used by  GraphiQL  for auto-generated documentation)    defaultValue  scalar  Default value of this input field", 
            "title": "Configuration options"
        }, 
        {
            "location": "/type-system/input-types/#using-input-object-type", 
            "text": "In the example above we defined our InputObjectType. Now let's use it in one of field arguments:  $queryType = new ObjectType([\n    'name' =  'Query',\n    'fields' =  [\n        'stories' =  [\n            'type' =  Type::listOf($storyType),\n            'args' =  [\n                'filters' =  [\n                    'type' =  Type::nonNull($filters),\n                    'defaultValue' =  [\n                        'popular' =  true\n                    ]\n                ]\n            ],\n            'resolve' =  function($rootValue, $args) {\n                return DataSource::filterStories($args['filters']);\n            }\n        ]\n    ]\n]);  (note that you can define  defaultValue  for fields with complex inputs as associative array).  Then GraphQL query could include filters as literal value:  {\n    stories(filters: {author:  1 , popular: false})\n}  Or as query variable:  query($filters: StoryFiltersInput!) {\n    stories(filters: $filters)\n}  $variables = [\n    'filters' =  [\n         author  =   1 ,\n         popular  =  false\n    ]\n];  graphql-php  will validate the input against your InputObjectType definition and pass it to your \nresolver as  $args['filters']", 
            "title": "Using Input Object Type"
        }, 
        {
            "location": "/type-system/directives/", 
            "text": "Built-in directives\n\n\nDirective is a way for client to give GraphQL server additional context and hints on how to execute\nthe query. Directive can be attached to a field or fragment inclusion, and can affect execution of the \nquery in any way the server desires.\n\n\nGraphQL specification includes two built-in directives:\n\n\n\n\n@include(if: Boolean)\n Only include this field or fragment in the result if the argument is \ntrue\n \n\n\n@skip(if: Boolean)\n Skip this field or fragment if the argument is \ntrue\n\n\n\n\nFor example:\n\n\nquery Hero($episode: Episode, $withFriends: Boolean!) {\n  hero(episode: $episode) {\n    name\n    friends @include(if: $withFriends) {\n      name\n    }\n  }\n}\n\n\n\n\nHere if \n$withFriends\n variable is set to \nfalse\n - friends section will be ignored and excluded \nfrom response. Important implementation detail: those fields will never be executed \n(not just removed from response after execution).\n\n\nCustom directives\n\n\ngraphql-php\n supports custom directives even though their presence does not affect execution of fields.\nBut you can use \nGraphQL\\Type\\Definition\\ResolveInfo\n in field resolvers to modify the output depending\non those directives or perform statistics collection.\n\n\nOther use case is your own query validation rules relying on custom directives.\n\n\nIn \ngraphql-php\n custom directive is an instance of \nGraphQL\\Type\\Definition\\Directive\n\n(or one of it subclasses) which accepts an array with following options:\n\n\nuse GraphQL\\Type\\Definition\\Directive;\nuse GraphQL\\Type\\Definition\\FieldArgument;\n\n$trackDirective = new Directive([\n    'name' =\n 'track',\n    'description' =\n 'Instruction to record usage of the field by client' \n    'locations' =\n [\n        Directive::LOCATION_FIELD,\n    ],\n    'args' =\n [\n        new FieldArgument([\n            'name' =\n 'details',\n            'type' =\n Type::string(),\n            'description' =\n 'String with additional details of field usage scenario'\n            'defaultValue' =\n ''\n        ])\n    ]\n]);\n\n\n\n\nDirective location can be one of the following values:\n\n\n\n\nDirective::LOCATION_QUERY\n\n\nDirective::LOCATION_MUTATION\n\n\nDirective::LOCATION_SUBSCRIPTION\n\n\nDirective::LOCATION_FIELD\n\n\nDirective::LOCATION_FRAGMENT_DEFINITION\n\n\nDirective::LOCATION_FRAGMENT_SPREAD\n\n\nDirective::LOCATION_INLINE_FRAGMENT", 
            "title": "Directives"
        }, 
        {
            "location": "/type-system/directives/#built-in-directives", 
            "text": "Directive is a way for client to give GraphQL server additional context and hints on how to execute\nthe query. Directive can be attached to a field or fragment inclusion, and can affect execution of the \nquery in any way the server desires.  GraphQL specification includes two built-in directives:   @include(if: Boolean)  Only include this field or fragment in the result if the argument is  true    @skip(if: Boolean)  Skip this field or fragment if the argument is  true   For example:  query Hero($episode: Episode, $withFriends: Boolean!) {\n  hero(episode: $episode) {\n    name\n    friends @include(if: $withFriends) {\n      name\n    }\n  }\n}  Here if  $withFriends  variable is set to  false  - friends section will be ignored and excluded \nfrom response. Important implementation detail: those fields will never be executed \n(not just removed from response after execution).", 
            "title": "Built-in directives"
        }, 
        {
            "location": "/type-system/directives/#custom-directives", 
            "text": "graphql-php  supports custom directives even though their presence does not affect execution of fields.\nBut you can use  GraphQL\\Type\\Definition\\ResolveInfo  in field resolvers to modify the output depending\non those directives or perform statistics collection.  Other use case is your own query validation rules relying on custom directives.  In  graphql-php  custom directive is an instance of  GraphQL\\Type\\Definition\\Directive \n(or one of it subclasses) which accepts an array with following options:  use GraphQL\\Type\\Definition\\Directive;\nuse GraphQL\\Type\\Definition\\FieldArgument;\n\n$trackDirective = new Directive([\n    'name' =  'track',\n    'description' =  'Instruction to record usage of the field by client' \n    'locations' =  [\n        Directive::LOCATION_FIELD,\n    ],\n    'args' =  [\n        new FieldArgument([\n            'name' =  'details',\n            'type' =  Type::string(),\n            'description' =  'String with additional details of field usage scenario'\n            'defaultValue' =  ''\n        ])\n    ]\n]);  Directive location can be one of the following values:   Directive::LOCATION_QUERY  Directive::LOCATION_MUTATION  Directive::LOCATION_SUBSCRIPTION  Directive::LOCATION_FIELD  Directive::LOCATION_FRAGMENT_DEFINITION  Directive::LOCATION_FRAGMENT_SPREAD  Directive::LOCATION_INLINE_FRAGMENT", 
            "title": "Custom directives"
        }, 
        {
            "location": "/type-system/schema/", 
            "text": "Schema Definition\n\n\nSchema is a container of your type hierarchy, which accepts root types in constructor and provides\nmethods for receiving information about your types to internal GrahpQL tools.\n\n\nIn \ngraphql-php\n schema is an instance of \nGraphQL\\Schema\n which accepts configuration array \nin constructor:\n\n\n$schema = new Schema([\n    'query' =\n $queryType, \n    'mutation' =\n $mutationType,\n]);\n\n\n\n\nSee possible constructor options \nbelow\n\n\nQuery and Mutation types\n\n\nSchema consists of two root types:\n\n\n\n\nQuery\n type is a surface of your read API\n\n\nMutation\n type (optional) exposes write API by declaring all possible mutations in your app. \n\n\n\n\nQuery and Mutation types are regular \nobject types\n containing root-level fields \nof your API:\n\n\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Schema;\n\n$queryType = new ObjectType([\n    'name' =\n 'Query',\n    'fields' =\n [\n        'hello' =\n [\n            'type' =\n Type::string(),\n            'resolve' =\n function() {\n                return 'Hello World!';\n            }\n        ]\n        'hero' =\n [\n            'type' =\n $characterInterface,\n            'args' =\n [\n                'episode' =\n [\n                    'type' =\n $episodeEnum\n                ]\n            ],\n            'resolve' =\n function ($rootValue, $args) {\n                return StarWarsData::getHero(isset($args['episode']) ? $args['episode'] : null);\n            },\n        ]\n    ]\n]);\n\n$mutationType = new ObjectType([\n    'name' =\n 'Mutation',\n    'fields' =\n [\n        'createReviewForEpisode' =\n [\n            'type' =\n $createReviewForEpisodeMutation,\n            'args' =\n [\n                'episode' =\n $episodeEnum,\n                'review' =\n $reviewInputObject\n            ],\n            'resolve' =\n function($val, $args) {\n                // TODOC\n            }\n        ]\n    ]\n]);\n\n\n\n\nKeep in mind that other than the special meaning of declaring surface area of your API, \nthose types are the same as any other \nobject type\n, and their fields work \nexactly the same way.\n\n\nMutation\n type is also just a regular object type. The difference is in semantics. \nField names of Mutation type are usually verbs and they almost always have arguments - quite often \nwith complex input values (see \nInput Types\n for details).\n\n\nConfiguration Options\n\n\nSchema constructor expects an array with following options:\n\n\n\n\n\n\n\n\nOption\n\n\nType\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nquery\n\n\nObjectType\n\n\nRequired.\n Object type (usually named \"Query\") containing root-level fields of your read API\n\n\n\n\n\n\nmutation\n\n\nObjectType\n\n\nObject type (usually named \"Mutation\") containing root-level fields of your write API\n\n\n\n\n\n\nsubscription\n\n\nObjectType\n\n\nReserved for future subscriptions implementation. Currently presented for compatibility with introspection query of \ngraphql-js\n, used by various clients (like Relay or GraphiQL)\n\n\n\n\n\n\ndirectives\n\n\nDirective[]\n\n\nFull list of \ndirectives\n supported by your schema. By default contains built-in \n@skip\n and \n@include\n directives.\n If you pass your own directives and still want to use built-in directives - add them explicitly. For example: \narray_merge(GraphQL::getInternalDirectives(), [$myCustomDirective]\n\n\n\n\n\n\ntypes\n\n\nObjectType[]\n\n\nList of object types which cannot be detected by \ngraphql-php\n during static schema analysis.\nMost often it happens when object type is never referenced in fields directly, but is still a part of schema because it implements an interface which resolves to this object type in it's \nresolveType\n callback. \n Note that you are not required to pass all of your types here - it is simply a workaround for concrete use-case.", 
            "title": "Schema"
        }, 
        {
            "location": "/type-system/schema/#schema-definition", 
            "text": "Schema is a container of your type hierarchy, which accepts root types in constructor and provides\nmethods for receiving information about your types to internal GrahpQL tools.  In  graphql-php  schema is an instance of  GraphQL\\Schema  which accepts configuration array \nin constructor:  $schema = new Schema([\n    'query' =  $queryType, \n    'mutation' =  $mutationType,\n]);  See possible constructor options  below", 
            "title": "Schema Definition"
        }, 
        {
            "location": "/type-system/schema/#query-and-mutation-types", 
            "text": "Schema consists of two root types:   Query  type is a surface of your read API  Mutation  type (optional) exposes write API by declaring all possible mutations in your app.    Query and Mutation types are regular  object types  containing root-level fields \nof your API:  use GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Schema;\n\n$queryType = new ObjectType([\n    'name' =  'Query',\n    'fields' =  [\n        'hello' =  [\n            'type' =  Type::string(),\n            'resolve' =  function() {\n                return 'Hello World!';\n            }\n        ]\n        'hero' =  [\n            'type' =  $characterInterface,\n            'args' =  [\n                'episode' =  [\n                    'type' =  $episodeEnum\n                ]\n            ],\n            'resolve' =  function ($rootValue, $args) {\n                return StarWarsData::getHero(isset($args['episode']) ? $args['episode'] : null);\n            },\n        ]\n    ]\n]);\n\n$mutationType = new ObjectType([\n    'name' =  'Mutation',\n    'fields' =  [\n        'createReviewForEpisode' =  [\n            'type' =  $createReviewForEpisodeMutation,\n            'args' =  [\n                'episode' =  $episodeEnum,\n                'review' =  $reviewInputObject\n            ],\n            'resolve' =  function($val, $args) {\n                // TODOC\n            }\n        ]\n    ]\n]);  Keep in mind that other than the special meaning of declaring surface area of your API, \nthose types are the same as any other  object type , and their fields work \nexactly the same way.  Mutation  type is also just a regular object type. The difference is in semantics. \nField names of Mutation type are usually verbs and they almost always have arguments - quite often \nwith complex input values (see  Input Types  for details).", 
            "title": "Query and Mutation types"
        }, 
        {
            "location": "/type-system/schema/#configuration-options", 
            "text": "Schema constructor expects an array with following options:     Option  Type  Notes      query  ObjectType  Required.  Object type (usually named \"Query\") containing root-level fields of your read API    mutation  ObjectType  Object type (usually named \"Mutation\") containing root-level fields of your write API    subscription  ObjectType  Reserved for future subscriptions implementation. Currently presented for compatibility with introspection query of  graphql-js , used by various clients (like Relay or GraphiQL)    directives  Directive[]  Full list of  directives  supported by your schema. By default contains built-in  @skip  and  @include  directives.  If you pass your own directives and still want to use built-in directives - add them explicitly. For example:  array_merge(GraphQL::getInternalDirectives(), [$myCustomDirective]    types  ObjectType[]  List of object types which cannot be detected by  graphql-php  during static schema analysis. Most often it happens when object type is never referenced in fields directly, but is still a part of schema because it implements an interface which resolves to this object type in it's  resolveType  callback.   Note that you are not required to pass all of your types here - it is simply a workaround for concrete use-case.", 
            "title": "Configuration Options"
        }, 
        {
            "location": "/executing-queries/", 
            "text": "Overview\n\n\nQuery execution is a complex process involving multiple steps, including query \nparsing\n, \n\nvalidating\n and finally \nexecuting\n against your \nschema\n.\n\n\ngraphql-php\n provides convenient facade for this process in class \nGraphQL\\GraphQL\n:\n\n\nuse GraphQL\\GraphQL;\n\n$result = GraphQL::execute(\n    $schema, \n    $queryString, \n    $rootValue = null, \n    $contextValue = null, \n    $variableValues = null, \n    $operationName = null\n);\n\n\n\n\nMethod returns \narray\n with \ndata\n and \nerrors\n keys, as described by \n\nGraphQL specs\n.\nThis array is suitable for further serialization (e.g. using \njson_encode\n). \nSee also section on \nerror handling\n.\n\n\nDescription of method arguments:\n\n\n\n\n\n\n\n\nArgument\n\n\nType\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nschema\n\n\nGraphQL\\Schema\n\n\nRequired.\n Instance of your application \nSchema\n\n\n\n\n\n\nqueryString\n\n\nstring\n or \nGraphQL\\Language\\AST\\DocumentNode\n\n\nRequired.\n Actual GraphQL query string to be parsed, validated and executed. If you parse query elsewhere before executing - pass corresponding ast document here to avoid new parsing.\n\n\n\n\n\n\nrootValue\n\n\nmixed\n\n\nAny value that represents a root of your data graph. It is passed as 1st argument to field resolvers of \nQuery type\n. Can be omitted or set to null if actual root values are fetched by Query type itself.\n\n\n\n\n\n\ncontextValue\n\n\nmixed\n\n\nAny value that holds information shared between all field resolvers. Most often they use it to pass currently logged in user, locale details, etc.\nIt will be available as 3rd argument in all field resolvers. (see section on \nField Definitions\n for reference) \ngraphql-php\n never modifies this value and passes it \nas is\n to all underlying resolvers.\n\n\n\n\n\n\nvariableValues\n\n\narray\n\n\nMap of variable values passed along with query string. See section on \nquery variables on official GraphQL website\n\n\n\n\n\n\noperationName\n\n\nstring\n\n\nAllows the caller to specify which operation in queryString will be run, in cases where queryString contains multiple top-level operations.\n\n\n\n\n\n\n\n\nParsing\n\n\nFollowing reading describes implementation details of query execution process. It may clarify some \ninternals of GraphQL but is not required in order to use it. Feel free to skip to next section \non \nError Handling\n for essentials.\n\n\nTODOC\n\n\nValidating\n\n\nTODOC\n\n\nExecuting\n\n\nTODOC", 
            "title": "Executing Queries"
        }, 
        {
            "location": "/executing-queries/#overview", 
            "text": "Query execution is a complex process involving multiple steps, including query  parsing ,  validating  and finally  executing  against your  schema .  graphql-php  provides convenient facade for this process in class  GraphQL\\GraphQL :  use GraphQL\\GraphQL;\n\n$result = GraphQL::execute(\n    $schema, \n    $queryString, \n    $rootValue = null, \n    $contextValue = null, \n    $variableValues = null, \n    $operationName = null\n);  Method returns  array  with  data  and  errors  keys, as described by  GraphQL specs .\nThis array is suitable for further serialization (e.g. using  json_encode ). \nSee also section on  error handling .  Description of method arguments:     Argument  Type  Notes      schema  GraphQL\\Schema  Required.  Instance of your application  Schema    queryString  string  or  GraphQL\\Language\\AST\\DocumentNode  Required.  Actual GraphQL query string to be parsed, validated and executed. If you parse query elsewhere before executing - pass corresponding ast document here to avoid new parsing.    rootValue  mixed  Any value that represents a root of your data graph. It is passed as 1st argument to field resolvers of  Query type . Can be omitted or set to null if actual root values are fetched by Query type itself.    contextValue  mixed  Any value that holds information shared between all field resolvers. Most often they use it to pass currently logged in user, locale details, etc. It will be available as 3rd argument in all field resolvers. (see section on  Field Definitions  for reference)  graphql-php  never modifies this value and passes it  as is  to all underlying resolvers.    variableValues  array  Map of variable values passed along with query string. See section on  query variables on official GraphQL website    operationName  string  Allows the caller to specify which operation in queryString will be run, in cases where queryString contains multiple top-level operations.", 
            "title": "Overview"
        }, 
        {
            "location": "/executing-queries/#parsing", 
            "text": "Following reading describes implementation details of query execution process. It may clarify some \ninternals of GraphQL but is not required in order to use it. Feel free to skip to next section \non  Error Handling  for essentials.  TODOC", 
            "title": "Parsing"
        }, 
        {
            "location": "/executing-queries/#validating", 
            "text": "TODOC", 
            "title": "Validating"
        }, 
        {
            "location": "/executing-queries/#executing", 
            "text": "TODOC", 
            "title": "Executing"
        }, 
        {
            "location": "/data-fetching/", 
            "text": "Overview\n\n\nGraphQL is data-storage agnostic. You can use any underlying data storage engine, including SQL or NoSQL database, \nplain files or in-memory data structures.\n\n\nIn order to convert GraphQL query to PHP array \ngraphql-php\n traverses query fields (using depth-first algorithm) and \nruns special \nresolve\n function on each field. This \nresolve\n function is provided by you as a part of \n\nfield definition\n.\n\n\nResult returned by \nresolve\n function is directly included in response (for scalars and enums)\nor passed down to nested fields (for objects).\n\n\nLet's walk through an example. Consider following GraphQL query:\n\n\n{\n  lastStory {\n    title\n    author {\n      name\n    }\n  }\n}\n\n\n\n\nWe need Schema that can fulfill it. On the very top level Schema contains Query type:\n\n\n$queryType = new ObjectType([\n  'name' =\n 'Query',\n  'fields' =\n [\n\n    'lastStory' =\n [\n      'type' =\n $blogStoryType,\n      'resolve' =\n function() {\n        return [\n          'id' =\n 1,\n          'title' =\n 'Example blog post',\n          'authorId' =\n 1\n        ];\n      }\n    ]\n\n  ]\n]);\n\n\n\n\nAs we see field \nlastStory\n has \nresolve\n function that is responsible for fetching data.\n\n\nIn our example we simply return array value, but in real-world application you would query\nyour database/cache/search index and return result.\n\n\nSince \nlastStory\n is of complex type \nBlogStory\n this result is passed down to fields of this type:\n\n\n$blogStoryType = new ObjectType([\n  'name' =\n 'BlogStory',\n  'fields' =\n [\n\n    'author' =\n [\n      'type' =\n $userType,\n      'resolve' =\n function($blogStory) {\n        $users = [\n          1 =\n [\n            'id' =\n 1,\n            'name' =\n 'Smith'\n          ],\n          2 =\n [\n            'id' =\n 2,\n            'name' =\n 'Anderson'\n          ]\n        ];\n        return $users[$blogStory['authorId']];\n      }\n    ],\n\n    'title' =\n [\n      'type' =\n Type::string()\n    ]\n\n  ]\n]);\n\n\n\n\nHere \n$blogStory\n is the array returned by \nlastStory\n field above. \n\n\nAgain: in real-world applications you would fetch user data from datastore by \nauthorId\n and return it.\nAlso note that you don't have to return arrays. You can return any value, \ngraphql-php\n will pass it untouched\nto nested resolvers.\n\n\nBut then the question appears - field \ntitle\n has no \nresolve\n option. How is it resolved?\n\n\nThe answer is: there is default resolver for all fields. When you define your own \nresolve\n function\nfor a field you simply override this default resolver.\n\n\nDefault Field Resolver\n\n\ngraphql-php\n provides following default field resolver:\n\n\nfunction defaultFieldResolver($source, $args, $context, ResolveInfo $info)\n{\n    $fieldName = $info-\nfieldName;\n    $property = null;\n\n    if (is_array($source) || $source instanceof \\ArrayAccess) {\n        if (isset($source[$fieldName])) {\n            $property = $source[$fieldName];\n        }\n    } else if (is_object($source)) {\n        if (isset($source-\n{$fieldName})) {\n            $property = $source-\n{$fieldName};\n        }\n    }\n\n    return $property instanceof \\Closure ? $property($source, $args, $context) : $property;\n}\n\n\n\n\nAs you see it returns value by key (for arrays) or property (for objects). If value is not set - it returns \nnull\n.\n\n\nTo override default resolver - use:\n\n\nGraphQL\\GraphQL::setDefaultFieldResolver($myResolverCallback);\n\n\n\n\nDefault Field Resolver per Type\n\n\nSometimes it might be convenient to set default field resolver per type. You can do so by providing\n\nresolveField option in type config\n. For example:\n\n\n$userType = new ObjectType([\n  'name' =\n 'User',\n  'fields' =\n [\n\n    'name' =\n Type::string(),\n    'email' =\n Type::string()\n\n  ],\n  'resolveField' =\n function(User $user, $args, $context, ResolveInfo $info) {\n    switch ($info-\nfieldName) {\n        case 'name':\n          return $user-\ngetName();\n        case 'email':\n          return $user-\ngetEmail();\n        default:\n          return null;\n    }\n  }\n]);\n\n\n\n\nKeep in mind that \nfield resolver\n has precedence over \ndefault field resolver per type\n which in turn\n has precedence over \ndefault field resolver\n.\n\n\nSolving N+1 Problem\n\n\nSince: 9.0\n\n\nOne of the most annoying problems with data fetching is so-called \nN+1 problem\n.\n\n\nConsider following GraphQL query:\n\n\n{\n  topStories(limit: 10) {\n    title\n    author {\n      name\n      email\n    }\n  }\n}\n\n\n\n\nNaive field resolution process would require up to 10 calls to underlying data store to fetch authors for all 10 stories.\n\n\ngraphql-php\n provides tools to mitigate this problem: it allows you to defer actual field resolution to later stage \nwhen one batched query could be executed instead of 10 distinct queries.\n\n\nHere is an example of \nBlogStory\n resolver for field \nauthor\n that uses deferring:\n\n\n'resolve' =\n function($blogStory) {\n    MyUserBuffer::add($blogStory['authorId']);\n\n    return new GraphQL\\Deferred(function () use ($blogStory) {\n        MyUserBuffer::loadOnce();\n        return MyUserBuffer::get($blogStory['authorId']);\n    });\n}\n\n\n\n\nIn this example we fill up buffer with 10 author ids first. Then \ngraphql-php\n continues \nresolving other non-deferred fields until there are none of them left.\n\n\nAfter that it calls \nClosures\n wrapped by \nGraphQL\\Deferred\n which in turn load all buffered \nids once (using SQL IN(?), Redis MGET or other similar tools) and return final field value.\n\n\nOriginally this approach was advocated by Facebook in their \nDataloader\n\nproject.\n\n\nThis solution enables very interesting optimizations at no cost. Consider following query:\n\n\n{\n  topStories(limit: 10) {\n    author {\n      email\n    }\n  }\n  category {\n    stories(limit: 10) {\n      author {\n        email\n      }\n    }\n  }\n}\n\n\n\n\nEven if \nauthor\n field is located on different levels of query - it can be buffered in the same buffer.\nIn this example only one query will be executed for all story authors comparing to 20 queries\nin naive implementation.\n\n\nAsync PHP\n\n\nSince: 9.0\n\n\nIf your project runs in environment that supports async operations \n(like \nHHVM\n, \nReactPHP\n, \nIcicle.io\n, \nappserver.io\n \nPHP threads\n, etc) you can leverage\nthe power of your platform to resolve fields asynchronously.\n\n\nThe only requirement: your platform must support the concept of Promises compatible with\n\nPromises A+\n specification.\n\n\nTo enable async support - set adapter for promises:\n\n\nGraphQL\\GraphQL::setPromiseAdapter($adapter);\n\n\n\n\nWhere \n$adapter\n is an instance of class implementing \nGraphQL\\Executor\\Promise\\PromiseAdapter\n interface.\n\n\nThen in your \nresolve\n functions you should return \nPromises\n of your platform instead of \n\nGraphQL\\Deferred\n instances.\n\n\nPlatforms supported out of the box:\n\n\n\n\nReactPHP\n (requires \nreact/promise\n as composer dependency):\n  \nGraphQL\\GraphQL::setPromiseAdapter(new GraphQL\\Executor\\Promise\\Adapter\\ReactPromiseAdapter());\n\n\nHHVM: TODO\n\n\n\n\nTo integrate other platform - implement \nGraphQL\\Executor\\Promise\\PromiseAdapter\n interface.", 
            "title": "Fetching Data"
        }, 
        {
            "location": "/data-fetching/#overview", 
            "text": "GraphQL is data-storage agnostic. You can use any underlying data storage engine, including SQL or NoSQL database, \nplain files or in-memory data structures.  In order to convert GraphQL query to PHP array  graphql-php  traverses query fields (using depth-first algorithm) and \nruns special  resolve  function on each field. This  resolve  function is provided by you as a part of  field definition .  Result returned by  resolve  function is directly included in response (for scalars and enums)\nor passed down to nested fields (for objects).  Let's walk through an example. Consider following GraphQL query:  {\n  lastStory {\n    title\n    author {\n      name\n    }\n  }\n}  We need Schema that can fulfill it. On the very top level Schema contains Query type:  $queryType = new ObjectType([\n  'name' =  'Query',\n  'fields' =  [\n\n    'lastStory' =  [\n      'type' =  $blogStoryType,\n      'resolve' =  function() {\n        return [\n          'id' =  1,\n          'title' =  'Example blog post',\n          'authorId' =  1\n        ];\n      }\n    ]\n\n  ]\n]);  As we see field  lastStory  has  resolve  function that is responsible for fetching data.  In our example we simply return array value, but in real-world application you would query\nyour database/cache/search index and return result.  Since  lastStory  is of complex type  BlogStory  this result is passed down to fields of this type:  $blogStoryType = new ObjectType([\n  'name' =  'BlogStory',\n  'fields' =  [\n\n    'author' =  [\n      'type' =  $userType,\n      'resolve' =  function($blogStory) {\n        $users = [\n          1 =  [\n            'id' =  1,\n            'name' =  'Smith'\n          ],\n          2 =  [\n            'id' =  2,\n            'name' =  'Anderson'\n          ]\n        ];\n        return $users[$blogStory['authorId']];\n      }\n    ],\n\n    'title' =  [\n      'type' =  Type::string()\n    ]\n\n  ]\n]);  Here  $blogStory  is the array returned by  lastStory  field above.   Again: in real-world applications you would fetch user data from datastore by  authorId  and return it.\nAlso note that you don't have to return arrays. You can return any value,  graphql-php  will pass it untouched\nto nested resolvers.  But then the question appears - field  title  has no  resolve  option. How is it resolved?  The answer is: there is default resolver for all fields. When you define your own  resolve  function\nfor a field you simply override this default resolver.", 
            "title": "Overview"
        }, 
        {
            "location": "/data-fetching/#default-field-resolver", 
            "text": "graphql-php  provides following default field resolver:  function defaultFieldResolver($source, $args, $context, ResolveInfo $info)\n{\n    $fieldName = $info- fieldName;\n    $property = null;\n\n    if (is_array($source) || $source instanceof \\ArrayAccess) {\n        if (isset($source[$fieldName])) {\n            $property = $source[$fieldName];\n        }\n    } else if (is_object($source)) {\n        if (isset($source- {$fieldName})) {\n            $property = $source- {$fieldName};\n        }\n    }\n\n    return $property instanceof \\Closure ? $property($source, $args, $context) : $property;\n}  As you see it returns value by key (for arrays) or property (for objects). If value is not set - it returns  null .  To override default resolver - use:  GraphQL\\GraphQL::setDefaultFieldResolver($myResolverCallback);", 
            "title": "Default Field Resolver"
        }, 
        {
            "location": "/data-fetching/#default-field-resolver-per-type", 
            "text": "Sometimes it might be convenient to set default field resolver per type. You can do so by providing resolveField option in type config . For example:  $userType = new ObjectType([\n  'name' =  'User',\n  'fields' =  [\n\n    'name' =  Type::string(),\n    'email' =  Type::string()\n\n  ],\n  'resolveField' =  function(User $user, $args, $context, ResolveInfo $info) {\n    switch ($info- fieldName) {\n        case 'name':\n          return $user- getName();\n        case 'email':\n          return $user- getEmail();\n        default:\n          return null;\n    }\n  }\n]);  Keep in mind that  field resolver  has precedence over  default field resolver per type  which in turn\n has precedence over  default field resolver .", 
            "title": "Default Field Resolver per Type"
        }, 
        {
            "location": "/data-fetching/#solving-n1-problem", 
            "text": "Since: 9.0  One of the most annoying problems with data fetching is so-called  N+1 problem .  Consider following GraphQL query:  {\n  topStories(limit: 10) {\n    title\n    author {\n      name\n      email\n    }\n  }\n}  Naive field resolution process would require up to 10 calls to underlying data store to fetch authors for all 10 stories.  graphql-php  provides tools to mitigate this problem: it allows you to defer actual field resolution to later stage \nwhen one batched query could be executed instead of 10 distinct queries.  Here is an example of  BlogStory  resolver for field  author  that uses deferring:  'resolve' =  function($blogStory) {\n    MyUserBuffer::add($blogStory['authorId']);\n\n    return new GraphQL\\Deferred(function () use ($blogStory) {\n        MyUserBuffer::loadOnce();\n        return MyUserBuffer::get($blogStory['authorId']);\n    });\n}  In this example we fill up buffer with 10 author ids first. Then  graphql-php  continues \nresolving other non-deferred fields until there are none of them left.  After that it calls  Closures  wrapped by  GraphQL\\Deferred  which in turn load all buffered \nids once (using SQL IN(?), Redis MGET or other similar tools) and return final field value.  Originally this approach was advocated by Facebook in their  Dataloader \nproject.  This solution enables very interesting optimizations at no cost. Consider following query:  {\n  topStories(limit: 10) {\n    author {\n      email\n    }\n  }\n  category {\n    stories(limit: 10) {\n      author {\n        email\n      }\n    }\n  }\n}  Even if  author  field is located on different levels of query - it can be buffered in the same buffer.\nIn this example only one query will be executed for all story authors comparing to 20 queries\nin naive implementation.", 
            "title": "Solving N+1 Problem"
        }, 
        {
            "location": "/data-fetching/#async-php", 
            "text": "Since: 9.0  If your project runs in environment that supports async operations \n(like  HHVM ,  ReactPHP ,  Icicle.io ,  appserver.io   PHP threads , etc) you can leverage\nthe power of your platform to resolve fields asynchronously.  The only requirement: your platform must support the concept of Promises compatible with Promises A+  specification.  To enable async support - set adapter for promises:  GraphQL\\GraphQL::setPromiseAdapter($adapter);  Where  $adapter  is an instance of class implementing  GraphQL\\Executor\\Promise\\PromiseAdapter  interface.  Then in your  resolve  functions you should return  Promises  of your platform instead of  GraphQL\\Deferred  instances.  Platforms supported out of the box:   ReactPHP  (requires  react/promise  as composer dependency):\n   GraphQL\\GraphQL::setPromiseAdapter(new GraphQL\\Executor\\Promise\\Adapter\\ReactPromiseAdapter());  HHVM: TODO   To integrate other platform - implement  GraphQL\\Executor\\Promise\\PromiseAdapter  interface.", 
            "title": "Async PHP"
        }, 
        {
            "location": "/error-handling/", 
            "text": "Errors in GraphQL\n\n\nQuery execution process never throws exceptions. Instead all errors that occur during query execution\nare caught, collected and included in response. \n\n\nThere are 3 types of errors in GraphQL (Syntax, Validation and Execution errors):\n\n\nSyntax\n errors are returned in response when query has invalid syntax and could not be parsed.\nExample output for invalid query \n{hello\n (missing bracket):\n\n\n[\n    'errors' =\n [\n        [\n            'message' =\n \nSyntax Error GraphQL request (1:7) Expected Name, found \nEOF\n\\n\\n1: {hello\\n         ^\\n\n,\n            'locations' =\n [\n                ['line' =\n 1, 'column' =\n 7]\n            ]\n        ]\n    ]\n]\n\n\n\n\nValidation\n errors - returned in response when query has semantic errors. \nExample output for invalid query \n{unknownField}\n:\n\n\n[\n    'errors' =\n [\n        [\n            'message' =\n 'Cannot query field \nunknownField\n on type \nQuery\n.',\n            'locations' =\n [\n                ['line' =\n 1, 'column' =\n 2]\n            ]\n        ]\n    ]\n]\n\n\n\n\nExecution\n errors - included in response when some field resolver throws \n(or returns unexpected value). Example output for query with exception thrown in \nfield resolver \n{fieldWithException}\n:\n\n\n[\n    'data' =\n [\n        'fieldWithException' =\n null\n    ],\n    'errors' =\n [\n        [\n            'message' =\n 'Exception message thrown in field resolver',\n            'locations' =\n [\n                ['line' =\n 1, 'column' =\n 2]\n            ],\n            'path': [\n                'fieldWithException'\n            ]\n        ]\n    ]\n]\n\n\n\n\nObviously when \nSyntax\n or \nValidation\n error is detected - process is interrupted and query is not \nexecuted. In such scenarios response only contains \nerrors\n, but not \ndata\n.\n\n\nGraphQL is forgiving to \nExecution\n errors which occur in resolvers of nullable fields. \nIf such field throws or returns unexpected value the value of the field in response will be simply \nreplaced with \nnull\n and error entry will be added to response.\n\n\nIf exception is thrown in non-null field - error bubbles up to first nullable field. This nullable field is\n\nreplaced with \nnull\n and error entry is added to response. If all fields up to the root are non-null - \n\ndata\n entry will be removed from response and only \nerrors\n key will be presented.\n\n\nDebugging tools\n\n\nEach error entry contains pointer to line and column in original query string which caused \nthe error:\n\n\n'locations' =\n [\n    ['line' =\n 1, 'column' =\n 2]\n]\n\n\n\n\nGraphQL clients like \nRelay\n or \nGraphiQL\n leverage this information to highlight \nactual piece of query containing error. \n\n\nIn some cases (like deep fragment fields) locations will include several entries to track down the \npath to field with error in query.\n\n\nExecution\n errors also contain \npath\n from the very root field to actual field value producing \nan error (including indexes for array types and fieldNames for object types). So in complex situation \nthis path could look like this:\n\n\n'path' =\n [\n    'lastStoryPosted',\n    'author',\n    'friends',\n    3\n    'fieldWithException'\n]\n\n\n\n\nCustom Error Formatting\n\n\nIf you want to apply custom formatting to errors - use \nGraphQL::executeAndReturnResult()\n instead\nof \nGraphQL::execute()\n.\n\n\nIt has exactly the same \nsignature\n, but instead of array it \nreturns \nGraphQL\\Executor\\ExecutionResult\n instance which holds errors in public \n$errors\n \nproperty and data in \n$data\n property.\n\n\nEach entry of \n$errors\n array contains instance of \nGraphQL\\Error\\Error\n which wraps original \nexceptions thrown by resolvers. To access original exceptions use \n$error-\ngetPrevious()\n method.\nBut note that previous exception is only available for \nExecution\n errors and will be \nnull\n\nfor \nSyntax\n or \nValidation\n errors.\n\n\nSchema Errors\n\n\nSo far we only covered errors which occur during query execution process. But schema definition can \nalso throw if there is an error in one of type definitions.\n\n\nUsually such errors mean that there is some logical error in your schema and it is the only case \nwhen it makes sense to return \n500\n error code for GraphQL endpoint:\n\n\ntry {\n    $schema = new Schema([\n        // ...\n    ]);\n\n    $body = GraphQL::execute($schema, $query);\n    $status = 200;\n} catch(\\Exception $e) {\n    $body = json_encode([\n        'message' =\n 'Unexpected error'\n    ]);\n    $status = 500;\n}\n\nheader('Content-Type: application/json', true, $status);\necho json_encode($body);", 
            "title": "Handling Errors"
        }, 
        {
            "location": "/error-handling/#errors-in-graphql", 
            "text": "Query execution process never throws exceptions. Instead all errors that occur during query execution\nare caught, collected and included in response.   There are 3 types of errors in GraphQL (Syntax, Validation and Execution errors):  Syntax  errors are returned in response when query has invalid syntax and could not be parsed.\nExample output for invalid query  {hello  (missing bracket):  [\n    'errors' =  [\n        [\n            'message' =   Syntax Error GraphQL request (1:7) Expected Name, found  EOF \\n\\n1: {hello\\n         ^\\n ,\n            'locations' =  [\n                ['line' =  1, 'column' =  7]\n            ]\n        ]\n    ]\n]  Validation  errors - returned in response when query has semantic errors. \nExample output for invalid query  {unknownField} :  [\n    'errors' =  [\n        [\n            'message' =  'Cannot query field  unknownField  on type  Query .',\n            'locations' =  [\n                ['line' =  1, 'column' =  2]\n            ]\n        ]\n    ]\n]  Execution  errors - included in response when some field resolver throws \n(or returns unexpected value). Example output for query with exception thrown in \nfield resolver  {fieldWithException} :  [\n    'data' =  [\n        'fieldWithException' =  null\n    ],\n    'errors' =  [\n        [\n            'message' =  'Exception message thrown in field resolver',\n            'locations' =  [\n                ['line' =  1, 'column' =  2]\n            ],\n            'path': [\n                'fieldWithException'\n            ]\n        ]\n    ]\n]  Obviously when  Syntax  or  Validation  error is detected - process is interrupted and query is not \nexecuted. In such scenarios response only contains  errors , but not  data .  GraphQL is forgiving to  Execution  errors which occur in resolvers of nullable fields. \nIf such field throws or returns unexpected value the value of the field in response will be simply \nreplaced with  null  and error entry will be added to response.  If exception is thrown in non-null field - error bubbles up to first nullable field. This nullable field is \nreplaced with  null  and error entry is added to response. If all fields up to the root are non-null -  data  entry will be removed from response and only  errors  key will be presented.", 
            "title": "Errors in GraphQL"
        }, 
        {
            "location": "/error-handling/#debugging-tools", 
            "text": "Each error entry contains pointer to line and column in original query string which caused \nthe error:  'locations' =  [\n    ['line' =  1, 'column' =  2]\n]  GraphQL clients like  Relay  or  GraphiQL  leverage this information to highlight \nactual piece of query containing error.   In some cases (like deep fragment fields) locations will include several entries to track down the \npath to field with error in query.  Execution  errors also contain  path  from the very root field to actual field value producing \nan error (including indexes for array types and fieldNames for object types). So in complex situation \nthis path could look like this:  'path' =  [\n    'lastStoryPosted',\n    'author',\n    'friends',\n    3\n    'fieldWithException'\n]", 
            "title": "Debugging tools"
        }, 
        {
            "location": "/error-handling/#custom-error-formatting", 
            "text": "If you want to apply custom formatting to errors - use  GraphQL::executeAndReturnResult()  instead\nof  GraphQL::execute() .  It has exactly the same  signature , but instead of array it \nreturns  GraphQL\\Executor\\ExecutionResult  instance which holds errors in public  $errors  \nproperty and data in  $data  property.  Each entry of  $errors  array contains instance of  GraphQL\\Error\\Error  which wraps original \nexceptions thrown by resolvers. To access original exceptions use  $error- getPrevious()  method.\nBut note that previous exception is only available for  Execution  errors and will be  null \nfor  Syntax  or  Validation  errors.", 
            "title": "Custom Error Formatting"
        }, 
        {
            "location": "/error-handling/#schema-errors", 
            "text": "So far we only covered errors which occur during query execution process. But schema definition can \nalso throw if there is an error in one of type definitions.  Usually such errors mean that there is some logical error in your schema and it is the only case \nwhen it makes sense to return  500  error code for GraphQL endpoint:  try {\n    $schema = new Schema([\n        // ...\n    ]);\n\n    $body = GraphQL::execute($schema, $query);\n    $status = 200;\n} catch(\\Exception $e) {\n    $body = json_encode([\n        'message' =  'Unexpected error'\n    ]);\n    $status = 500;\n}\n\nheader('Content-Type: application/json', true, $status);\necho json_encode($body);", 
            "title": "Schema Errors"
        }, 
        {
            "location": "/complementary-tools/", 
            "text": "Integrations\n\n\n\n\nIntegration with Relay\n\n\nIntegration with Laravel 5\n + \nRelay Helpers for Laravel\n\n\nSymfony Bundle\n by Overblog\n\n\n\n\nTools\n\n\n\n\nGraphiQL\n - An in-browser IDE for exploring GraphQL\n\n\nChromeiQL\n\n  or \nGraphiQL Feen\n -\n  GraphiQL as Google Chrome extension", 
            "title": "Complementary Tools"
        }, 
        {
            "location": "/complementary-tools/#integrations", 
            "text": "Integration with Relay  Integration with Laravel 5  +  Relay Helpers for Laravel  Symfony Bundle  by Overblog", 
            "title": "Integrations"
        }, 
        {
            "location": "/complementary-tools/#tools", 
            "text": "GraphiQL  - An in-browser IDE for exploring GraphQL  ChromeiQL \n  or  GraphiQL Feen  -\n  GraphiQL as Google Chrome extension", 
            "title": "Tools"
        }
    ]
}